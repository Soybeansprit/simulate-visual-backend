package com.example.demo.service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;

import org.springframework.stereotype.Service;

import java.util.Stack;

import com.example.demo.bean.BiddableType;
import com.example.demo.bean.CauseRule;
import com.example.demo.bean.Conflict;
import com.example.demo.bean.ConflictReason;
import com.example.demo.bean.DataTimeValue;
import com.example.demo.bean.DeviceAnalysisResult;
import com.example.demo.bean.DeviceDetail;
import com.example.demo.bean.DeviceType;
import com.example.demo.bean.IFDGraph.GraphNode;
import com.example.demo.bean.IFDGraph.GraphNodeArrow;
import com.example.demo.bean.JitterReason;
import com.example.demo.bean.ReachableReason;
import com.example.demo.bean.Rule;
import com.example.demo.bean.RuleNode;
import com.example.demo.bean.Scene;
@Service
public class DynamicAnalysisService {

	public static void main(String[] args) {
		String result="\r\n" + 
				"temperature: (0,14) (0,14) (1,14) (1,14) (30,28.4999999999969) (30.00000000000184,28.49999999999782) (57.99999999999697,14.50000000000008) (57.99999999999697,14.50000000000008) (86.00000000000703,28.49999999999782) (86.00000000000703,28.49999999999782) (114.0000000000213,14.50000000000008) (114.0000000000213,14.50000000000008) (142.0000000000158,28.49999999999783) (142.0000000000158,28.49999999999783) (169.9999999999903,14.50000000000008) (169.9999999999903,14.50000000000008) (197.9999999999649,28.49999999999783) (197.9999999999649,28.49999999999783) (225.9999999999394,14.50000000000008) (225.9999999999394,14.50000000000008) (252.9999999999148,27.99999999999793) (252.9999999999148,27.99999999999793) (300.0099999998721,27.99999999999793)\r\n" + 
				"dtemper: (0,0) (0,0) (1,0) (1,0) (1.07,0.5) (1.07,0.5) (30,0.5) (30.00000000000184,0.5) (30.07000000000185,-0.5) (30.07000000000185,-0.5) (57.99999999999697,-0.5) (57.99999999999697,-0.5) (58.06999999999696,0.5) (58.06999999999696,0.5) (86.00000000000703,0.5) (86.00000000000703,0.5) (86.07000000000707,-0.5) (86.07000000000707,-0.5) (114.0000000000213,-0.5) (114.0000000000213,-0.5) (114.0700000000214,0.5) (114.0700000000214,0.5) (142.0000000000158,0.5) (142.0000000000158,0.5) (142.0700000000157,-0.5) (142.0700000000157,-0.5) (169.9999999999903,-0.5) (169.9999999999903,-0.5) (170.0699999999903,0.5) (170.0699999999903,0.5) (197.9999999999649,0.5) (197.9999999999649,0.5) (198.0699999999648,-0.5) (198.0699999999648,-0.5) (225.9999999999394,-0.5) (225.9999999999394,-0.5) (226.0699999999393,0.5) (226.0699999999393,0.5) (252.9999999999148,0.5) (252.9999999999148,0.5) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"humidity: (0,19) (0,19) (1,19) (1,19) (252.9999999999148,144.9999999999401) (252.9999999999148,144.9999999999401) (300.0099999998721,144.9999999999401)\r\n" + 
				"dhumi: (0,0) (0,0) (1,0) (1,0) (1.07,0.5) (1.07,0.5) (252.9999999999148,0.5) (252.9999999999148,0.5) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"pm_2_5: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"dpm_2_5: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"co2ppm: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"dco2ppm: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"aqi: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"dapi: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"fire: (0,0) (0,0) (90.00000000000355,0) (90.00000000000355,0) (90.0700000000091,1) (90.0700000000091,1) (120.0000000000171,1) (120.0700000000245,0) (120.0700000000245,0) (300.0099999998721,0)\r\n" + 
				"wind: (0,0) (0,0) (299.9999999998537,0) (299.9999999998537,0) (300.0099999998721,1)\r\n" + 
				"rain: (0,0) (0,0) (269.9999999998828,0) (269.9999999998828,0) (270.0699999998993,1) (270.0699999998993,1) (299.9999999998537,1) (299.9999999998537,1) (300.0099999998721,0)\r\n" + 
				"position: (0,0) (0,0) (42,0) (42,0) (42.07000000000014,1) (42.07000000000014,1) (84,1) (84,1) (84.07000000000605,2) (84.07000000000605,2) (126,2) (126,2) (126.0700000000275,3) (126.0700000000275,3) (167.9999999999922,3) (168,3) (168.0699999999999,4) (168.0699999999999,4) (209.9999999999411,4) (210,4) (210.0699999999999,5) (210.0699999999999,5) (251.9999999999158,5) (252,5) (252.0699999999999,6) (252.0699999999999,6) (300.0099999998721,6)\r\n" + 
				"deviceName=Window_3,deviceType=Window,location=Location2: (0,0) (0,0) (84,0) (84.00000000000601,0) (84.07000000000605,1) (84.07000000000605,1) (85.00000000000652,1) (85.00000000000652,1) (85.07000000000656,0) (85.07000000000656,0) (86.00000000000703,0) (86.00000000000703,0) (86.07000000000707,1) (86.07000000000707,1) (87.00000000000755,1) (87.00000000000755,1) (87.07000000000758,0) (87.07000000000758,0) (88.00000000000806,0) (88.00000000000806,0) (88.00000000000806,1) (88.07000000000809,0) (89.00000000000857,0) (89.00000000000857,0) (89.0700000000086,1) (89.0700000000086,1) (90.00000000000355,1) (90.00000000000907,1) (90.0700000000091,0) (90.0700000000091,0) (91.00000000000958,0) (91.00000000000958,0) (91.00000000000958,1) (91.07000000000961,0) (92.00000000001009,0) (92.00000000001009,0) (92.00000000001009,1) (92.07000000001013,0) (93.0000000000106,0) (93.0000000000106,0) (93.0000000000106,1) (93.07000000001064,0) (94.00000000001111,0) (94.00000000001111,0) (94.07000000001115,1) (94.07000000001115,1) (95.00000000001162,1) (95.00000000001162,1) (95.07000000001166,0) (95.07000000001166,0) (96.00000000001214,0) (96.00000000001214,0) (96.07000000001217,1) (96.07000000001217,1) (97.00000000001265,1) (97.00000000001265,1) (97.00000000001265,0) (97.07000000001268,1) (98.00000000001316,1) (98.00000000001316,1) (98.00000000001316,0) (98.0700000000132,1) (99.00000000001367,1) (99.00000000001367,1) (99.07000000001371,0) (99.07000000001371,0) (100.0000000000142,0) (100.0000000000142,0) (100.0700000000142,1) (100.0700000000142,1) (101.0000000000147,1) (101.0000000000147,1) (101.0000000000147,0) (101.0700000000147,1) (102.0000000000152,1) (102.0000000000152,1) (102.0700000000152,0) (102.0700000000152,0) (103.0000000000157,0) (103.0000000000157,0) (103.0700000000158,1) (103.0700000000158,1) (104.0000000000162,1) (104.0000000000162,1) (104.0700000000163,0) (104.0700000000163,0) (105.0000000000167,0) (105.0000000000167,0) (105.0700000000168,1) (105.0700000000168,1) (106.0000000000173,1) (106.0000000000173,1) (106.0700000000173,0) (106.0700000000173,0) (107.0000000000178,0) (107.0000000000178,0) (107.0700000000178,1) (107.0700000000178,1) (108.0000000000183,1) (108.0000000000183,1) (108.0700000000183,0) (108.0700000000183,0) (109.0000000000188,0) (109.0000000000188,0) (109.0000000000188,1) (109.0700000000188,0) (110.0000000000193,0) (110.0000000000193,0) (110.0000000000193,1) (110.0700000000193,0) (111.0000000000198,0) (111.0000000000198,0) (111.0000000000198,1) (111.0700000000198,0) (112.0000000000203,0) (112.0000000000203,0) (112.0700000000204,1) (112.0700000000204,1) (113.0000000000208,1) (113.0000000000208,1) (113.0700000000209,0) (113.0700000000209,0) (114.0000000000213,0) (114.0000000000213,0) (114.0700000000214,1) (114.0700000000214,1) (115.0000000000219,1) (115.0000000000219,1) (115.0700000000219,0) (115.0700000000219,0) (116.0000000000224,0) (116.0000000000224,0) (116.0000000000224,1) (116.0700000000224,0) (117.0000000000229,0) (117.0000000000229,0) (117.0000000000229,1) (117.0700000000229,0) (118.0000000000234,0) (118.0000000000234,0) (118.0000000000234,1) (118.0700000000234,0) (119.0000000000239,0) (119.0000000000239,0) (119.0000000000239,1) (119.0700000000239,0) (120.0000000000171,0) (120.0000000000244,0) (120.0700000000245,1) (120.0700000000245,1) (121.0000000000249,1) (121.0000000000249,1) (121.0000000000249,0) (121.070000000025,1) (122.0000000000254,1) (122.0000000000254,1) (122.0000000000254,0) (122.0700000000255,1) (123.0000000000259,1) (123.0000000000259,1) (123.070000000026,0) (123.070000000026,0) (124.0000000000265,0) (124.0000000000265,0) (124.0700000000265,1) (124.0700000000265,1) (125.000000000027,1) (125.000000000027,1) (125.070000000027,0) (125.070000000027,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Window_2,deviceType=Window,location=Location1: (0,0) (0,0) (42,0) (42.00000000000016,0) (42.07000000000014,1) (42.07000000000014,1) (42.99999999999996,1) (42.99999999999996,1) (42.99999999999996,0) (43.06999999999994,1) (43.99999999999976,1) (43.99999999999976,1) (43.99999999999976,0) (44.06999999999974,1) (44.99999999999956,1) (44.99999999999956,1) (45.06999999999955,0) (45.06999999999955,0) (45.99999999999936,0) (45.99999999999936,0) (46.06999999999935,1) (46.06999999999935,1) (46.99999999999916,1) (46.99999999999916,1) (46.99999999999916,0) (47.06999999999915,1) (47.99999999999896,1) (47.99999999999896,1) (48.06999999999895,0) (48.06999999999895,0) (48.99999999999876,0) (48.99999999999876,0) (49.06999999999875,1) (49.06999999999875,1) (49.99999999999856,1) (49.99999999999856,1) (49.99999999999856,0) (50.06999999999855,1) (50.99999999999837,1) (50.99999999999837,1) (50.99999999999837,0) (51.06999999999835,1) (51.99999999999817,1) (51.99999999999817,1) (52.06999999999815,0) (52.06999999999815,0) (52.99999999999797,0) (52.99999999999797,0) (52.99999999999797,1) (53.06999999999795,0) (53.99999999999777,0) (53.99999999999777,0) (53.99999999999777,1) (54.06999999999775,0) (54.99999999999757,0) (54.99999999999757,0) (54.99999999999757,1) (55.06999999999756,0) (55.99999999999737,0) (55.99999999999737,0) (56.06999999999736,1) (56.06999999999736,1) (56.99999999999717,1) (56.99999999999717,1) (57.06999999999716,0) (57.06999999999716,0) (57.99999999999697,0) (57.99999999999697,0) (58.06999999999696,1) (58.06999999999696,1) (58.99999999999677,1) (58.99999999999677,1) (58.99999999999677,0) (59.06999999999676,1) (59.99999999999289,1) (59.99999999999658,1) (59.99999999999658,0) (60.06999999999656,1) (60.99999999999638,1) (60.99999999999638,1) (60.99999999999638,0) (61.06999999999636,1) (61.99999999999618,1) (61.99999999999618,1) (61.99999999999618,0) (62.06999999999616,1) (62.99999999999598,1) (62.99999999999598,1) (62.99999999999598,0) (63.06999999999596,1) (63.99999999999578,1) (63.99999999999578,1) (64.06999999999582,0) (64.06999999999582,0) (64.99999999999629,0) (64.99999999999629,0) (64.99999999999629,1) (65.06999999999633,0) (65.9999999999968,0) (65.9999999999968,0) (66.06999999999684,1) (66.06999999999684,1) (66.99999999999731,1) (66.99999999999731,1) (66.99999999999731,0) (67.06999999999735,1) (67.99999999999783,1) (67.99999999999783,1) (67.99999999999783,0) (68.06999999999786,1) (68.99999999999834,1) (68.99999999999834,1) (68.99999999999834,0) (69.06999999999837,1) (69.99999999999885,1) (69.99999999999885,1) (70.06999999999888,0) (70.06999999999888,0) (70.99999999999936,0) (70.99999999999936,0) (70.99999999999936,1) (71.0699999999994,0) (71.99999999999987,0) (71.99999999999987,0) (72.06999999999991,1) (72.06999999999991,1) (73.00000000000038,1) (73.00000000000038,1) (73.07000000000042,0) (73.07000000000042,0) (74.0000000000009,0) (74.0000000000009,0) (74.0000000000009,1) (74.07000000000093,0) (75.00000000000141,0) (75.00000000000141,0) (75.00000000000141,1) (75.07000000000144,0) (76.00000000000192,0) (76.00000000000192,0) (76.00000000000192,1) (76.07000000000195,0) (77.00000000000243,0) (77.00000000000243,0) (77.07000000000247,1) (77.07000000000247,1) (78.00000000000294,1) (78.00000000000294,1) (78.00000000000294,0) (78.07000000000298,1) (79.00000000000345,1) (79.00000000000345,1) (79.07000000000349,0) (79.07000000000349,0) (80.00000000000396,0) (80.00000000000396,0) (80.070000000004,1) (80.070000000004,1) (81.00000000000448,1) (81.00000000000448,1) (81.00000000000448,0) (81.07000000000451,1) (82.00000000000499,1) (82.00000000000499,1) (82.00000000000499,0) (82.07000000000502,1) (83.0000000000055,1) (83.0000000000055,1) (83.0000000000055,0) (83.07000000000554,1) (84,1) (84.00000000000601,1) (84.07000000000605,0) (84.07000000000605,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Window_1,deviceType=Window,location=Location1: (0,0) (0,0) (42,0) (42.00000000000016,0) (42.07000000000014,1) (42.07000000000014,1) (42.99999999999996,1) (42.99999999999996,1) (42.99999999999996,0) (43.06999999999994,1) (43.99999999999976,1) (43.99999999999976,1) (43.99999999999976,0) (44.06999999999974,1) (44.99999999999956,1) (44.99999999999956,1) (45.06999999999955,0) (45.06999999999955,0) (45.99999999999936,0) (45.99999999999936,0) (46.06999999999935,1) (46.06999999999935,1) (46.99999999999916,1) (46.99999999999916,1) (46.99999999999916,0) (47.06999999999915,1) (47.99999999999896,1) (47.99999999999896,1) (48.06999999999895,0) (48.06999999999895,0) (48.99999999999876,0) (48.99999999999876,0) (49.06999999999875,1) (49.06999999999875,1) (49.99999999999856,1) (49.99999999999856,1) (49.99999999999856,0) (50.06999999999855,1) (50.99999999999837,1) (50.99999999999837,1) (50.99999999999837,0) (51.06999999999835,1) (51.99999999999817,1) (51.99999999999817,1) (52.06999999999815,0) (52.06999999999815,0) (52.99999999999797,0) (52.99999999999797,0) (52.99999999999797,1) (53.06999999999795,0) (53.99999999999777,0) (53.99999999999777,0) (53.99999999999777,1) (54.06999999999775,0) (54.99999999999757,0) (54.99999999999757,0) (54.99999999999757,1) (55.06999999999756,0) (55.99999999999737,0) (55.99999999999737,0) (56.06999999999736,1) (56.06999999999736,1) (56.99999999999717,1) (56.99999999999717,1) (57.06999999999716,0) (57.06999999999716,0) (57.99999999999697,0) (57.99999999999697,0) (58.06999999999696,1) (58.06999999999696,1) (58.99999999999677,1) (58.99999999999677,1) (58.99999999999677,0) (59.06999999999676,1) (59.99999999999289,1) (59.99999999999658,1) (59.99999999999658,0) (60.06999999999656,1) (60.99999999999638,1) (60.99999999999638,1) (60.99999999999638,0) (61.06999999999636,1) (61.99999999999618,1) (61.99999999999618,1) (61.99999999999618,0) (62.06999999999616,1) (62.99999999999598,1) (62.99999999999598,1) (62.99999999999598,0) (63.06999999999596,1) (63.99999999999578,1) (63.99999999999578,1) (64.06999999999582,0) (64.06999999999582,0) (64.99999999999629,0) (64.99999999999629,0) (64.99999999999629,1) (65.06999999999633,0) (65.9999999999968,0) (65.9999999999968,0) (66.06999999999684,1) (66.06999999999684,1) (66.99999999999731,1) (66.99999999999731,1) (66.99999999999731,0) (67.06999999999735,1) (67.99999999999783,1) (67.99999999999783,1) (67.99999999999783,0) (68.06999999999786,1) (68.99999999999834,1) (68.99999999999834,1) (68.99999999999834,0) (69.06999999999837,1) (69.99999999999885,1) (69.99999999999885,1) (70.06999999999888,0) (70.06999999999888,0) (70.99999999999936,0) (70.99999999999936,0) (70.99999999999936,1) (71.0699999999994,0) (71.99999999999987,0) (71.99999999999987,0) (72.06999999999991,1) (72.06999999999991,1) (73.00000000000038,1) (73.00000000000038,1) (73.07000000000042,0) (73.07000000000042,0) (74.0000000000009,0) (74.0000000000009,0) (74.0000000000009,1) (74.07000000000093,0) (75.00000000000141,0) (75.00000000000141,0) (75.00000000000141,1) (75.07000000000144,0) (76.00000000000192,0) (76.00000000000192,0) (76.00000000000192,1) (76.07000000000195,0) (77.00000000000243,0) (77.00000000000243,0) (77.07000000000247,1) (77.07000000000247,1) (78.00000000000294,1) (78.00000000000294,1) (78.00000000000294,0) (78.07000000000298,1) (79.00000000000345,1) (79.00000000000345,1) (79.07000000000349,0) (79.07000000000349,0) (80.00000000000396,0) (80.00000000000396,0) (80.070000000004,1) (80.070000000004,1) (81.00000000000448,1) (81.00000000000448,1) (81.00000000000448,0) (81.07000000000451,1) (82.00000000000499,1) (82.00000000000499,1) (82.00000000000499,0) (82.07000000000502,1) (83.0000000000055,1) (83.0000000000055,1) (83.0000000000055,0) (83.07000000000554,1) (84,1) (84.00000000000601,1) (84.07000000000605,0) (84.07000000000605,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Window_4,deviceType=Window,location=Location5: (0,0) (0,0) (210.999999999953,0) (210.999999999953,0) (211.069999999953,1) (211.069999999953,1) (211.9999999999521,1) (211.9999999999521,1) (212.0699999999521,0) (212.0699999999521,0) (212.9999999999512,0) (212.9999999999512,0) (213.0699999999512,1) (213.0699999999512,1) (213.9999999999503,1) (213.9999999999503,1) (214.0699999999503,0) (214.0699999999503,0) (214.9999999999494,0) (214.9999999999494,0) (214.9999999999494,1) (215.0699999999493,0) (215.9999999999485,0) (215.9999999999485,0) (215.9999999999485,1) (216.0699999999484,0) (216.9999999999476,0) (216.9999999999476,0) (216.9999999999476,1) (217.0699999999475,0) (217.9999999999467,0) (217.9999999999467,0) (218.0699999999466,1) (218.0699999999466,1) (218.9999999999458,1) (218.9999999999458,1) (219.0699999999457,0) (219.0699999999457,0) (219.9999999999449,0) (219.9999999999449,0) (219.9999999999449,1) (220.0699999999448,0) (220.999999999944,0) (220.999999999944,0) (220.999999999944,1) (221.0699999999439,0) (221.999999999943,0) (221.999999999943,0) (222.069999999943,1) (222.069999999943,1) (222.9999999999421,1) (222.9999999999421,1) (222.9999999999421,0) (223.0699999999421,1) (223.9999999999412,1) (223.9999999999412,1) (223.9999999999412,0) (224.0699999999412,1) (224.9999999999403,1) (224.9999999999403,1) (224.9999999999403,0) (225.0699999999403,1) (225.9999999999394,1) (225.9999999999394,1) (226.0699999999393,0) (226.0699999999393,0) (226.9999999999385,0) (226.9999999999385,0) (227.0699999999384,1) (227.0699999999384,1) (227.9999999999376,1) (227.9999999999376,1) (228.0699999999375,0) (228.0699999999375,0) (228.9999999999367,0) (228.9999999999367,0) (229.0699999999366,1) (229.0699999999366,1) (229.9999999999358,1) (229.9999999999358,1) (229.9999999999358,0) (230.0699999999357,1) (230.9999999999349,1) (230.9999999999349,1) (230.9999999999349,0) (231.0699999999348,1) (231.9999999999339,1) (231.9999999999339,1) (231.9999999999339,0) (232.0699999999339,1) (232.999999999933,1) (232.999999999933,1) (232.999999999933,0) (233.069999999933,1) (233.9999999999321,1) (233.9999999999321,1) (233.9999999999321,0) (234.0699999999321,1) (234.9999999999312,1) (234.9999999999312,1) (235.0699999999312,0) (235.0699999999312,0) (235.9999999999303,0) (235.9999999999303,0) (236.0699999999302,1) (236.0699999999302,1) (236.9999999999294,1) (236.9999999999294,1) (236.9999999999294,0) (237.0699999999293,1) (237.9999999999285,1) (237.9999999999285,1) (237.9999999999285,0) (238.0699999999284,1) (238.9999999999276,1) (238.9999999999276,1) (238.9999999999276,0) (239.0699999999275,1) (239.9999999999119,1) (239.9999999999267,1) (240.0699999999266,0) (240.0699999999266,0) (240.9999999999258,0) (240.9999999999258,0) (241.0699999999257,1) (241.0699999999257,1) (241.9999999999249,1) (241.9999999999249,1) (241.9999999999249,0) (242.0699999999248,1) (242.9999999999239,1) (242.9999999999239,1) (242.9999999999239,0) (243.0699999999239,1) (243.999999999923,1) (243.999999999923,1) (244.069999999923,0) (244.069999999923,0) (244.9999999999221,0) (244.9999999999221,0) (245.0699999999221,1) (245.0699999999221,1) (245.9999999999212,1) (245.9999999999212,1) (246.0699999999212,0) (246.0699999999212,0) (246.9999999999203,0) (246.9999999999203,0) (247.0699999999202,1) (247.0699999999202,1) (247.9999999999194,1) (247.9999999999194,1) (248.0699999999193,0) (248.0699999999193,0) (248.9999999999185,0) (248.9999999999185,0) (249.0699999999184,1) (249.0699999999184,1) (249.9999999999176,1) (249.9999999999176,1) (249.9999999999176,0) (250.0699999999175,1) (250.9999999999167,1) (250.9999999999167,1) (250.9999999999167,0) (251.0699999999166,1) (251.9999999999158,1) (251.9999999999158,1) (251.9999999999158,0) (252.0699999999999,1) (252.9999999999148,1) (252.9999999999148,1) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Window_0,deviceType=Window,location=Location4: (0,0) (0,0) (168.9999999999912,0) (168.9999999999912,0) (169.0699999999912,1) (169.0699999999912,1) (169.9999999999903,1) (169.9999999999903,1) (170.0699999999903,0) (170.0699999999903,0) (170.9999999999894,0) (170.9999999999894,0) (171.0699999999894,1) (171.0699999999894,1) (171.9999999999885,1) (171.9999999999885,1) (171.9999999999885,0) (172.0699999999885,1) (172.9999999999876,1) (172.9999999999876,1) (173.0699999999875,0) (173.0699999999875,0) (173.9999999999867,0) (173.9999999999867,0) (174.0699999999866,1) (174.0699999999866,1) (174.9999999999858,1) (174.9999999999858,1) (174.9999999999858,0) (175.0699999999857,1) (175.9999999999849,1) (175.9999999999849,1) (176.0699999999848,0) (176.0699999999848,0) (176.999999999984,0) (176.999999999984,0) (177.0699999999839,1) (177.0699999999839,1) (177.9999999999831,1) (177.9999999999831,1) (177.9999999999831,0) (178.069999999983,1) (178.9999999999822,1) (178.9999999999822,1) (178.9999999999822,0) (179.0699999999821,1) (179.9999999999702,1) (179.9999999999812,1) (179.9999999999812,0) (180.0699999999812,1) (180.9999999999803,1) (180.9999999999803,1) (181.0699999999803,0) (181.0699999999803,0) (181.9999999999794,0) (181.9999999999794,0) (181.9999999999794,1) (182.0699999999794,0) (182.9999999999785,0) (182.9999999999785,0) (182.9999999999785,1) (183.0699999999784,0) (183.9999999999776,0) (183.9999999999776,0) (184.0699999999775,1) (184.0699999999775,1) (184.9999999999767,1) (184.9999999999767,1) (185.0699999999766,0) (185.0699999999766,0) (185.9999999999758,0) (185.9999999999758,0) (186.0699999999757,1) (186.0699999999757,1) (186.9999999999749,1) (186.9999999999749,1) (187.0699999999748,0) (187.0699999999748,0) (187.999999999974,0) (187.999999999974,0) (188.0699999999739,1) (188.0699999999739,1) (188.9999999999731,1) (188.9999999999731,1) (189.069999999973,0) (189.069999999973,0) (189.9999999999721,0) (189.9999999999721,0) (190.0699999999721,1) (190.0699999999721,1) (190.9999999999712,1) (190.9999999999712,1) (190.9999999999712,0) (191.0699999999712,1) (191.9999999999703,1) (191.9999999999703,1) (192.0699999999703,0) (192.0699999999703,0) (192.9999999999694,0) (192.9999999999694,0) (193.0699999999694,1) (193.0699999999694,1) (193.9999999999685,1) (193.9999999999685,1) (194.0699999999684,0) (194.0699999999684,0) (194.9999999999676,0) (194.9999999999676,0) (194.9999999999676,1) (195.0699999999675,0) (195.9999999999667,0) (195.9999999999667,0) (195.9999999999667,1) (196.0699999999666,0) (196.9999999999658,0) (196.9999999999658,0) (197.0699999999657,1) (197.0699999999657,1) (198.999999999964,1) (198.999999999964,1) (198.999999999964,0) (199.0699999999639,1) (199.9999999999631,1) (199.9999999999631,1) (199.9999999999631,0) (200.069999999963,1) (200.9999999999621,1) (200.9999999999621,1) (200.9999999999621,0) (201.0699999999621,1) (201.9999999999612,1) (201.9999999999612,1) (202.0699999999612,0) (202.0699999999612,0) (202.9999999999603,0) (202.9999999999603,0) (202.9999999999603,1) (203.0699999999603,0) (203.9999999999594,0) (203.9999999999594,0) (203.9999999999594,1) (204.0699999999594,0) (204.9999999999585,0) (204.9999999999585,0) (204.9999999999585,1) (205.0699999999584,0) (205.9999999999576,0) (205.9999999999576,0) (206.0699999999575,1) (206.0699999999575,1) (206.9999999999567,1) (206.9999999999567,1) (206.9999999999567,0) (207.0699999999566,1) (207.9999999999558,1) (207.9999999999558,1) (207.9999999999558,0) (208.0699999999557,1) (208.9999999999549,1) (208.9999999999549,1) (208.9999999999549,0) (209.0699999999548,1) (209.9999999999411,1) (209.999999999954,1) (209.999999999954,0) (210.0699999999999,1) (210.999999999953,1) (210.999999999953,1) (211.069999999953,0) (211.069999999953,0) (300.0099999998721,0)\r\n" + 
				"deviceName=TV_0,deviceType=TV,location=Location1: (0,0) (0,0) (42,0) (42.00000000000016,0) (42.07000000000014,1) (42.07000000000014,1) (252.9999999999148,1) (252.9999999999148,1) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Robot_0,deviceType=Robot,location=Location1: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Fan_0,deviceType=Fan,location=Location1: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Blind_0,deviceType=Blind,location=Location2: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Blind_2,deviceType=Blind,location=Location5: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Blind_1,deviceType=Blind,location=Location4: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Bulb_8,deviceType=Bulb,location=Location5: (0,0) (0,0) (210.999999999953,0) (210.999999999953,0) (211.069999999953,1) (211.069999999953,1) (300.0099999998721,1)\r\n" + 
				"deviceName=Bulb_7,deviceType=Bulb,location=Location4: (0,0) (0,0) (168.9999999999912,0) (168.9999999999912,0) (169.0699999999912,1) (169.0699999999912,1) (300.0099999998721,1)\r\n" + 
				"deviceName=Bulb_6,deviceType=Bulb,location=Location4: (0,0) (0,0) (168.9999999999912,0) (168.9999999999912,0) (169.0699999999912,1) (169.0699999999912,1) (300.0099999998721,1)\r\n" + 
				"deviceName=Bulb_5,deviceType=Bulb,location=Location3: (0,0) (0,0) (126,0) (126.0000000000275,0) (126.0700000000275,1) (126.0700000000275,1) (252.9999999999148,1) (252.9999999999148,1) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Bulb_4,deviceType=Bulb,location=Location3: (0,0) (0,0) (126,0) (126.0000000000275,0) (126.0700000000275,1) (126.0700000000275,1) (252.9999999999148,1) (252.9999999999148,1) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Bulb_3,deviceType=Bulb,location=Location2: (0,0) (0,0) (84,0) (84.00000000000601,0) (84.07000000000605,1) (84.07000000000605,1) (252.9999999999148,1) (252.9999999999148,1) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Bulb_2,deviceType=Bulb,location=Location2: (0,0) (0,0) (84,0) (84.00000000000601,0) (84.07000000000605,1) (84.07000000000605,1) (252.9999999999148,1) (252.9999999999148,1) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Bulb_1,deviceType=Bulb,location=Location1: (0,0) (0,0) (42,0) (42.00000000000016,0) (42.07000000000014,1) (42.07000000000014,1) (252.9999999999148,1) (252.9999999999148,1) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Bulb_0,deviceType=Bulb,location=Location1: (0,0) (0,0) (42,0) (42.00000000000016,0) (42.07000000000014,1) (42.07000000000014,1) (252.9999999999148,1) (252.9999999999148,1) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Dehumidifier_0,deviceType=Dehumidifier,location=Location1: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Alarm_0,deviceType=Alarm,location=Location1: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"deviceName=AirPurifier_0,deviceType=AirPurifier,location=Location1: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Heater_0,deviceType=Heater,location=Badroom: (0,0) (0,0) (300.0099999998721,0)\r\n" + 
				"deviceName=Humidifier_0,deviceType=Humidifier,location=Location1: (0,0) (0,0) (1,0) (1,0) (1.07,1) (1.07,1) (252.9999999999148,1) (252.9999999999148,1) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"deviceName=AirConditioner_0,deviceType=AirConditioner,location=Location1: (0,0) (0,0) (1,0) (1,0) (1.07,2) (1.07,2) (30,2) (30.00000000000184,2) (30.07000000000185,1) (30.07000000000185,1) (57.99999999999697,1) (57.99999999999697,1) (58.06999999999696,2) (58.06999999999696,2) (86.00000000000703,2) (86.00000000000703,2) (86.07000000000707,1) (86.07000000000707,1) (114.0000000000213,1) (114.0000000000213,1) (114.0700000000214,2) (114.0700000000214,2) (142.0000000000158,2) (142.0000000000158,2) (142.0700000000157,1) (142.0700000000157,1) (169.9999999999903,1) (169.9999999999903,1) (170.0699999999903,2) (170.0699999999903,2) (197.9999999999649,2) (197.9999999999649,2) (198.0699999999648,1) (198.0699999999648,1) (225.9999999999394,1) (225.9999999999394,1) (226.0699999999393,2) (226.0699999999393,2) (252.9999999999148,2) (252.9999999999148,2) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"rule1: (0,0) (0,0) (1,0) (1,0) (1.07,1) (1.07,1) (2.999999999999978,1) (2.999999999999978,1) (3.069999999999977,0) (3.069999999999977,0) (57.99999999999697,0) (57.99999999999697,0) (58.06999999999696,1) (58.06999999999696,1) (58.99999999999677,1) (58.99999999999677,1) (59.06999999999676,0) (59.06999999999676,0) (114.0000000000213,0) (114.0000000000213,0) (114.0700000000214,1) (114.0700000000214,1) (115.0000000000219,1) (115.0000000000219,1) (115.0700000000219,0) (115.0700000000219,0) (169.9999999999903,0) (169.9999999999903,0) (170.0699999999903,1) (170.0699999999903,1) (170.9999999999894,1) (170.9999999999894,1) (171.0699999999894,0) (171.0699999999894,0) (225.9999999999394,0) (225.9999999999394,0) (226.0699999999393,1) (226.0699999999393,1) (226.9999999999385,1) (226.9999999999385,1) (227.0699999999384,0) (227.0699999999384,0) (300.0099999998721,0)\r\n" + 
				"rule2: (0,0) (0,0) (30,0) (30.00000000000184,0) (30.07000000000185,1) (30.07000000000185,1) (31.00000000000199,1) (31.00000000000199,1) (31.070000000002,0) (31.070000000002,0) (86.00000000000703,0) (86.00000000000703,0) (86.07000000000707,1) (86.07000000000707,1) (87.00000000000755,1) (87.00000000000755,1) (87.07000000000758,0) (87.07000000000758,0) (142.0000000000158,0) (142.0000000000158,0) (142.0700000000157,1) (142.0700000000157,1) (143.0000000000149,1) (143.0000000000149,1) (143.0700000000148,0) (143.0700000000148,0) (197.9999999999649,0) (197.9999999999649,0) (198.0699999999648,1) (198.0699999999648,1) (198.999999999964,1) (198.999999999964,1) (199.0699999999639,0) (199.0699999999639,0) (300.0099999998721,0)\r\n" + 
				"rule3: (0,0) (0,0) (1,0) (1,0) (1.07,1) (1.07,1) (3.999999999999956,1) (3.999999999999956,1) (4.069999999999955,0) (4.069999999999955,0) (300.0099999998721,0)\r\n" + 
				"rule4: (0,0) (0,0) (42,0) (42.00000000000016,0) (42.07000000000014,1) (42.07000000000014,1) (84,1) (84.00000000000601,1) (84.07000000000605,0) (84.07000000000605,0) (300.0099999998721,0)\r\n" + 
				"rule5: (0,0) (0,0) (42,0) (42.00000000000016,0) (42.07000000000014,1) (42.07000000000014,1) (84,1) (84.00000000000601,1) (84.07000000000605,0) (84.07000000000605,0) (300.0099999998721,0)\r\n" + 
				"rule6: (0,0) (0,0) (84,0) (84.00000000000601,0) (84.07000000000605,1) (84.07000000000605,1) (126,1) (126.0000000000275,1) (126.0700000000275,0) (126.0700000000275,0) (300.0099999998721,0)\r\n" + 
				"rule7: (0,0) (0,0) (168.9999999999912,0) (168.9999999999912,0) (169.0699999999912,1) (169.0699999999912,1) (210.999999999953,1) (210.999999999953,1) (211.069999999953,0) (211.069999999953,0) (300.0099999998721,0)\r\n" + 
				"rule8: (0,0) (0,0) (126,0) (126.0000000000275,0) (126.0700000000275,1) (126.0700000000275,1) (168.9999999999912,1) (168.9999999999912,1) (169.0699999999912,0) (169.0699999999912,0) (300.0099999998721,0)\r\n" + 
				"rule9: (0,0) (0,0) (210.999999999953,0) (210.999999999953,0) (211.069999999953,1) (211.069999999953,1) (252.9999999999148,1) (252.9999999999148,1) (253.0699999999148,0) (253.0699999999148,0) (300.0099999998721,0)\r\n" + 
				"rule10: (0,0) (0,0) (252.9999999999148,0) (252.9999999999148,0) (253.0699999999148,1) (253.0699999999148,1) (300.0099999998721,1)\r\n" + 
				"rule11: (0,0) (0,0) (252.9999999999148,0) (252.9999999999148,0) (253.0699999999148,1) (253.0699999999148,1) (300.0099999998721,1)\r\n" + 
				"rule12: (0,0) (0,0) (252.9999999999148,0) (252.9999999999148,0) (253.0699999999148,1) (253.0699999999148,1) (300.0099999998721,1)\r\n" + 
				"rule13: (0,0) (0,0) (269.9999999998828,0) (269.9999999998994,0) (270.0699999998993,1) (270.0699999998993,1) (299.9999999998537,1) (299.9999999998721,1) (300.0099999998721,0)\r\n" + 
				"rule14: (0,0) (0,0) (31.00000000000199,0) (31.00000000000199,0) (31.070000000002,1) (31.070000000002,1) (57.99999999999697,1) (57.99999999999697,1) (58.06999999999696,0) (58.06999999999696,0) (87.00000000000755,0) (87.00000000000755,0) (87.07000000000758,1) (87.07000000000758,1) (114.0000000000213,1) (114.0000000000213,1) (114.0700000000214,0) (114.0700000000214,0) (143.0000000000149,0) (143.0000000000149,0) (143.0700000000148,1) (143.0700000000148,1) (169.9999999999903,1) (169.9999999999903,1) (170.0699999999903,0) (170.0699999999903,0) (198.999999999964,0) (198.999999999964,0) (199.0699999999639,1) (199.0699999999639,1) (225.9999999999394,1) (225.9999999999394,1) (226.0699999999393,0) (226.0699999999393,0) (300.0099999998721,0)\r\n" + 
				"rule15: (0,0) (0,0) (1,0) (1,0) (1.07,1) (1.07,1) (30,1) (30.00000000000184,1) (30.07000000000185,0) (30.07000000000185,0) (58.99999999999677,0) (58.99999999999677,0) (59.06999999999676,1) (59.06999999999676,1) (87.00000000000755,1) (87.00000000000755,1) (87.07000000000758,0) (87.07000000000758,0) (115.0000000000219,0) (115.0000000000219,0) (115.0700000000219,1) (115.0700000000219,1) (143.0000000000149,1) (143.0000000000149,1) (143.0700000000148,0) (143.0700000000148,0) (169.9999999999903,0) (169.9999999999903,0) (170.0699999999903,1) (170.0699999999903,1) (197.9999999999649,1) (197.9999999999649,1) (198.0699999999648,0) (198.0699999999648,0) (225.9999999999394,0) (225.9999999999394,0) (226.0699999999393,1) (226.0699999999393,1) (253.9999999999139,1) (253.9999999999139,1) (254.0699999999139,0) (254.0699999999139,0) (300.0099999998721,0)\r\n" + 
				"rule16: (0,0) (0,0) (299.9999999998537,0) (299.9999999998721,0) (300.0099999998721,1)\r\n" + 
				"rule17: (0,0) (0,0) (252.9999999999148,0) (252.9999999999148,0) (253.0699999999148,1) (253.0699999999148,1) (300.0099999998721,1)\r\n" + 
				"time: (0,0) (0,0) (300.0099999998721,300.0099999998721)\r\n" + 
				"";
		List<DataTimeValue> dataTimeValues=getAllDataTimeValues(result);
		System.out.println(dataTimeValues);
		HashMap<String, List<double[]>> dataTimeValuesHashMap=getDataTimeValuesHashMap(result);
		HashMap<String,List<double[]>> dataStartTimeValueEndTimeValuesMap=new HashMap<>();
		for(Entry<String,List<double[]>> dataTimeValue:dataTimeValuesHashMap.entrySet()) {
			dataStartTimeValueEndTimeValuesMap.put(dataTimeValue.getKey(), getStartTimeValueEndTimeValuesHashMap(dataTimeValue.getValue()));
			
		}
		for(Entry<String,List<double[]>> dataTimeValue:dataTimeValuesHashMap.entrySet()) {
			List<ConflictReason> conflictReasons=conflictAnalysis(dataTimeValue.getValue());
			System.out.println(conflictReasons);
			List<double[]> startTimeValueEndTimeValues=dataStartTimeValueEndTimeValuesMap.get(dataTimeValue.getKey());
			jitterAnalysis(startTimeValueEndTimeValues, "300", "24", "300");
			
		}
		
	}
	
	/////动态分析数据,包括设备状态冲突和设备抖动
	public static void getAllScenariosDynamicAnalysis(List<Scene> scenes,List<DeviceDetail> devices,HashMap<String,Rule> rulesMap,String simulationTime,String equivalentTime,String intervalTime,List<GraphNode> graphNodes) {
		/////rules=>rulesMap
//		HashMap<String,Rule> rulesMap=new HashMap<>();
//		for(Rule rule:rules) {
//			rulesMap.put(rule.getRuleName(), rule);
//		}
		
		/////获得ifd上各节点
//		List<GraphNode> graphNodes=StaticAnalysisService.getIFDNode(ifdFileName, filePath);
		
		/////获得每条规则的前提rules
//		List<RuleNode> rulePreRulesNodes=DynamicAnalysisService.getRulePreRules(graphNodes, rulesMap);
		
		for(Scene scene:scenes) {
			/////单个场景分析
			getSingleScenarioDynamicAnalysis(scene, devices, graphNodes, rulesMap);
//			////先获得场景dataTimeValue和startTimeValueEndTimeValue的hashmap
//			getSceneDataHashMap(scene);
//			List<DeviceAnalysisResult> deviceAnalysisResults=new ArrayList<>();
//			for(DeviceDetail device:devices) {
//				///找到对应设备节点
//				GraphNode deviceNode=new GraphNode();
//				for(GraphNode node:graphNodes) {
//					if(node.getName().equals(device.getDeviceName())) {
//						deviceNode=node;
//						break;
//					}
//				}
//				////分析设备
//				DeviceAnalysisResult deviceAnalysisResult=new DeviceAnalysisResult();
//				deviceAnalysisResult.setDeviceName(device.getDeviceName());
//				List<ConflictReason> conflictReasons=DynamicAnalysisService.conflictAnalysis(scene.getDataTimeValuesHashMap().get(device.getDeviceName()));
//				List<JitterReason> jitterReasons=DynamicAnalysisService.jitterAnalysis(scene.getDataStartTimeValueEndTimeValuesHashMap().get(device.getDeviceName()), "300", "24", "300");
//				////分析问题原因
//				if(conflictReasons!=null) {
//					System.out.println(device.getDeviceName()+" conflict");
//					for(ConflictReason conflictReason:conflictReasons) {
//						////每次conflict原因
//						getConflictReason(scene, conflictReason, device, deviceNode,graphNodes,rulesMap);
////						System.out.println(causingRules);
//						
//					}
//				}
//				if(jitterReasons.size()>0) {
//					System.out.println(device.getDeviceName()+" jitter");
//					for(JitterReason jitterReason:jitterReasons) {
//						////每次jitter原因
//						DynamicAnalysisService.getJitterReason(scene, jitterReason, device, deviceNode,graphNodes,rulesMap);
////						System.out.println(causingRules);
//					}
//				}
//				
//				
//				deviceAnalysisResult.setConflictReasons(conflictReasons);
//				deviceAnalysisResult.setJitterReasons(jitterReasons);
//				deviceAnalysisResults.add(deviceAnalysisResult);
//			}
//			scene.setDeviceAnalysisResults(deviceAnalysisResults);
		}
		
	}
	
	public static void getSingleScenarioDynamicAnalysis(Scene scene,List<DeviceDetail> devices,List<GraphNode> graphNodes,HashMap<String,Rule> rulesMap) {
		////先获得场景dataTimeValue和startTimeValueEndTimeValue的hashmap
		getSceneDataHashMap(scene);
		List<DeviceAnalysisResult> deviceAnalysisResults=new ArrayList<>();
		for(DeviceDetail device:devices) {
			///找到对应设备节点
			GraphNode deviceNode=new GraphNode();
			for(GraphNode node:graphNodes) {
				if(node.getName().equals(device.getDeviceName())) {
					deviceNode=node;
					break;
				}
			}
			////分析设备
			DeviceAnalysisResult deviceAnalysisResult=new DeviceAnalysisResult();
			deviceAnalysisResult.setDeviceName(device.getDeviceName());
			List<ConflictReason> conflictReasons=DynamicAnalysisService.conflictAnalysis(scene.getDataTimeValuesHashMap().get(device.getDeviceName()));
			List<JitterReason> jitterReasons=DynamicAnalysisService.jitterAnalysis(scene.getDataStartTimeValueEndTimeValuesHashMap().get(device.getDeviceName()), "300", "24", "300");
			////分析问题原因
			if(conflictReasons.size()>0) {
				System.out.println(device.getDeviceName()+" conflict");
				for(ConflictReason conflictReason:conflictReasons) {
					////每次conflict原因
					getConflictReason(scene, conflictReason, device, deviceNode,graphNodes,rulesMap);
//					System.out.println(causingRules);
					
				}
			}
			if(jitterReasons.size()>0) {
				System.out.println(device.getDeviceName()+" jitter");
				for(JitterReason jitterReason:jitterReasons) {
					////每次jitter原因
					DynamicAnalysisService.getJitterReason(scene, jitterReason, device, deviceNode,graphNodes,rulesMap);
//					System.out.println(causingRules);
				}
			}
			
			
			deviceAnalysisResult.setConflictReasons(conflictReasons);
			deviceAnalysisResult.setJitterReasons(jitterReasons);
			deviceAnalysisResults.add(deviceAnalysisResult);
		}
		scene.setDeviceAnalysisResults(deviceAnalysisResults);
	}
	
	public static void  getJitterReason(Scene scene,JitterReason jitterReason,DeviceDetail device,GraphNode deviceNode,List<GraphNode> graphNodes,HashMap<String,Rule> rulesMap) {
		////IFD上找所有规则的前提规则
		List<RuleNode> rulePreRules=getRulePreRules(graphNodes, rulesMap);
		HashMap<String,RuleNode> rulePreRulesMap=new HashMap<>();
		List<CauseRule> causingRules=new ArrayList<>();
		for(RuleNode rulePreRule:rulePreRules) {
			rulePreRulesMap.put(rulePreRule.getRule().getRuleName(), rulePreRule);
		}
		List<Integer> differentValues=new ArrayList<>();  ///抖动的状态
		for(double[] timeValue:jitterReason.getJitter()) {
			boolean exist=false;
			Integer stateValue=(int) timeValue[1];  ////状态值
			for(Integer value:differentValues) {
				if(value.equals(stateValue)) {
					exist=true;
					break;
				}
			}
			if(!exist) {
				differentValues.add(stateValue);
			}
		}
		for(Integer value:differentValues) {
			////找到对应的设备状态的action
			for(String[] stateActionValue:device.getDeviceType().stateActionValues) {
				if(value==Integer.parseInt(stateActionValue[2])) {
					String action=stateActionValue[1];
					////找到IFD上的相关规则
					List<RuleNode> relatedRulePreRules=getRelatedRulesFromIFD(action, deviceNode,rulePreRulesMap);
					////再看能否被触发
					List<RuleNode> stateCausingRules=getCanTriggeredRules(relatedRulePreRules, scene.getDataStartTimeValueEndTimeValuesHashMap(), jitterReason.getJitter().get(0)[0], jitterReason.getJitter().get(jitterReason.getJitter().size()-1)[0]);

					CauseRule causingRule=new CauseRule();
					causingRule.setState(stateActionValue[0]);
					causingRule.setValue(Integer.parseInt(stateActionValue[2]));
					causingRule.setStateCausingRules(stateCausingRules);
					causingRules.add(causingRule);
				}
			}
		}
		jitterReason.setCausingRules(causingRules);
	}
	
	//////寻找哪些规则导致的状态冲突和抖动
	public static void getConflictReason(Scene scene,ConflictReason conflictReason,DeviceDetail device,GraphNode deviceNode,List<GraphNode> graphNodes,HashMap<String,Rule> rulesMap) {

		////IFD上找所有规则的前提规则
		List<RuleNode> rulePreRules=getRulePreRules(graphNodes, rulesMap);
		HashMap<String,RuleNode> rulePreRulesMap=new HashMap<>();
//		List<List<RuleNode>> statesCausingRules=new ArrayList<>();
		List<CauseRule> causingRules=new ArrayList<>();
		for(RuleNode rulePreRule:rulePreRules) {
			rulePreRulesMap.put(rulePreRule.getRule().getRuleName(), rulePreRule);
		}
		for(double value:conflictReason.getConflict().getConflictValues()) {
			////找到值对应的action
			
			for(String[] stateActionValue:device.getDeviceType().stateActionValues) {
				if((int)value==Integer.parseInt(stateActionValue[2])) {
					String action=stateActionValue[1];
//					List<String> stateCausingRules=new ArrayList<>();
					////找到IFD上的该action相关规则，以及前提规则
					List<RuleNode> relatedRulePreRules=getRelatedRulesFromIFD(action, deviceNode,rulePreRulesMap);
					
					////再看能否被触发
					////找到相关规则
					List<RuleNode> stateCausingRules=getCanTriggeredRules(relatedRulePreRules, scene.getDataStartTimeValueEndTimeValuesHashMap(), conflictReason.getConflict().getTime());

					CauseRule causingRule=new CauseRule();
					causingRule.setState(stateActionValue[0]);
					causingRule.setValue(Integer.parseInt(stateActionValue[2]));
					causingRule.setStateCausingRules(stateCausingRules);
					causingRules.add(causingRule);
//					statesCausingRules.add(stateCausingRules);
				}
			}
		}
		conflictReason.setCausingRules(causingRules);
	}
	
	/////冲突对应的
	public static List<RuleNode> getCanTriggeredRules(List<RuleNode> relatedRulePreRules,HashMap<String,List<double[]>> dataStartTimeValueEndTimeValuesMap,double conflictTime) {
		////再看能否被触发

		List<RuleNode> stateCausingRules=new ArrayList<>();
		////删除不能发生的，包括preRule
		for(RuleNode rule:relatedRulePreRules) {
			if(canTriggered(conflictTime, dataStartTimeValueEndTimeValuesMap.get(rule.getRule().getRuleName()))) {
				////如果当前规则能触发，则看是否有前提规则
				stateCausingRules.add(rule);  ////存进去
				Stack<RuleNode> ruleStack=new Stack<>();
				ruleStack.push(rule);
				while(!ruleStack.isEmpty()) {
					////看当前这条规则后面的能否发生
					RuleNode currentRuleNode=ruleStack.pop();
					if(currentRuleNode!=null)
					for(int i=0;i<currentRuleNode.getPreRules().size();i++) {
						RuleNode currentPreRule=currentRuleNode.getPreRules().get(i);
						if(canTriggered(0, conflictTime,dataStartTimeValueEndTimeValuesMap.get(rule.getRule().getRuleName()))) {
							////如果下个rule也能触发，就加进来
							ruleStack.push(currentPreRule);
						}else {
							///不能触发则直接设置为null
							currentRuleNode.setPreRules(i, null);
						}
					}
				}
			}

		}
		return stateCausingRules;
	}
	
	/////jitter对应的
	public static List<RuleNode> getCanTriggeredRules(List<RuleNode> relatedRulePreRules,HashMap<String,List<double[]>> dataStartTimeValueEndTimeValuesMap,double startTime,double endTime) {
		////再看能否被触发

		List<RuleNode> stateCausingRules=new ArrayList<>();
		////删除不能发生的，包括preRule
		for(RuleNode rule:relatedRulePreRules) {
			if(canTriggered(startTime,endTime, dataStartTimeValueEndTimeValuesMap.get(rule.getRule().getRuleName()))) {
				////如果当前规则能触发，则看是否有前提规则
				stateCausingRules.add(rule);  ////存进去
				Stack<RuleNode> ruleStack=new Stack<>();
				ruleStack.push(rule);
				while(!ruleStack.isEmpty()) {
					////看当前这条规则后面的能否发生
					RuleNode currentRuleNode=ruleStack.pop();
					if(currentRuleNode!=null)
					for(int i=0;i<currentRuleNode.getPreRules().size();i++) {
						RuleNode currentPreRule=currentRuleNode.getPreRules().get(i);
						if(canTriggered(0, endTime,dataStartTimeValueEndTimeValuesMap.get(rule.getRule().getRuleName()))) {
							////如果下个rule也能触发，就加进来
							ruleStack.push(currentPreRule);
						}else {
							///不能触发则直接设置为null
							currentRuleNode.setPreRules(i, null);
						}
					}
				}
			}

		}
		return stateCausingRules;
	}
	
	/////看对应的规则能否触发
	public static boolean canTriggered(double startTime,double endTime,List<double[]> startTimeValueEndTimeValues) {
		if(startTimeValueEndTimeValues==null)
		System.out.println(startTimeValueEndTimeValues);
		for(double[] startTimeValueEndTimeValue:startTimeValueEndTimeValues) {
			/////找到对应时间点是否触发
			if(startTimeValueEndTimeValue[1]>0 && startTimeValueEndTimeValue[3]>0) {
				if(!(startTimeValueEndTimeValue[0]>=endTime)&&!(startTimeValueEndTimeValue[2]<=startTime)) {
					///有在范围内，则表明触发了
					return true;
					
				}
			}
			if(startTimeValueEndTimeValue[0]>endTime) {
				////已经超出范围了
				break;
			}
		}
		return false;
	}
	public static boolean canTriggered(double conflictTime,List<double[]> startTimeValueEndTimeValues) {
		for(double[] startTimeValueEndTimeValue:startTimeValueEndTimeValues) {
			/////找到对应时间点是否触发
			if(!(startTimeValueEndTimeValue[0]>=conflictTime)&&!(startTimeValueEndTimeValue[2]<=conflictTime)
					&& startTimeValueEndTimeValue[1]>0 && startTimeValueEndTimeValue[3]>0) {
				/////(t1,v1,t2,v2)  if (t1<=conflictTime<=t2 && v1=v2=1) 则说明触发了
				return true;				
			}
			if(startTimeValueEndTimeValue[0]>conflictTime) {
				////已经超出范围了
				break;
			}
		}
		return false;
	}

	//////找抖动时触发的规则，获得对应时间范围内触发了哪些规则
	public static List<String> getTriggeredRules(double startTime,double endTime,HashMap<String,List<double[]>> startTimeValueEndTimeValuesMap){
		List<String> triggeredRules=new ArrayList<String>();
		for(Entry<String,List<double[]>> dataStartTimeValueEndTimeValues:startTimeValueEndTimeValuesMap.entrySet()) {
			if(dataStartTimeValueEndTimeValues.getKey().contains("rule")) {
				/////找到规则的仿真数据
				for(double[] startTimeValueEndTimeValue:dataStartTimeValueEndTimeValues.getValue()) {
					/////找到对应时间点是否触发
					if(startTimeValueEndTimeValue[1]>0 && startTimeValueEndTimeValue[3]>0) {
						if(!(startTimeValueEndTimeValue[0]>=endTime)&&!(startTimeValueEndTimeValue[2]<=startTime)) {
							///有在范围内，则表明触发了
							triggeredRules.add(dataStartTimeValueEndTimeValues.getKey());
							break;
						}
					}
				}
			}
		}
		
		return triggeredRules;
	}
	
	///////找冲突时触发的规则
	public static List<String> getTriggeredRules(double conflictTime,HashMap<String,List<double[]>> startTimeValueEndTimeValuesMap){
		List<String> triggeredRules=new ArrayList<String>();
		for(Entry<String,List<double[]>> dataStartTimeValueEndTimeValues:startTimeValueEndTimeValuesMap.entrySet()) {
			if(dataStartTimeValueEndTimeValues.getKey().contains("rule")) {
				/////找到规则的仿真数据
				for(double[] startTimeValueEndTimeValue:dataStartTimeValueEndTimeValues.getValue()) {
					/////找到对应时间点是否触发
					/////(t1,v1,t2,v2)  if (t1<=conflictTime<=t2 && v1=v2=1) 则说明触发了
					if(startTimeValueEndTimeValue[0]<=conflictTime&&startTimeValueEndTimeValue[2]>=conflictTime
							&& startTimeValueEndTimeValue[1]>0 && startTimeValueEndTimeValue[3]>0) {
						triggeredRules.add(dataStartTimeValueEndTimeValues.getKey());
						break;
					}
				}
			}
		}
		
		return triggeredRules;
	}
	
	///////先根据值从IFD上找相关规则，以及对应的前提规则
	public static List<RuleNode> getRelatedRulesFromIFD(String action,GraphNode deviceNode,HashMap<String,RuleNode> ruleNodesMap) {
		GraphNode actionNode=new GraphNode();
		List<String> relatedRules=new ArrayList<>();
		List<RuleNode> relatedRuleNodes=new ArrayList<>();
		for(GraphNodeArrow cArrow:deviceNode.getcNodeList()) {
			//////找到相关actionNode
			if(cArrow.getGraphNode().getLabel().endsWith(action)) {
				actionNode=cArrow.getGraphNode();
				break;
			}
		}
		////找到所有会执行该action的ruleNodes
		for(GraphNodeArrow pArrow:actionNode.getpNodeList()) {
			if(pArrow.getGraphNode().getShape().equals("hexagon")) {
				relatedRules.add(pArrow.getGraphNode().getName());
				/////找到规则和其前提规则
				relatedRuleNodes.add(ruleNodesMap.get(pArrow.getGraphNode().getName()));
			}
		}
		return relatedRuleNodes;
	}
	
	/////找到每条规则的前提规则
	public static List<RuleNode> getRulePreRules(List<GraphNode> graphNodes, HashMap<String,Rule> rulesMap){ 
		List<RuleNode> rulePreRulesNodes=new ArrayList<>();
		for(GraphNode graphNode:graphNodes) {
			if(graphNode.getShape().equals("hexagon")) {
				////找到规则节点
				RuleNode rulePreRulesNode=new RuleNode();
				Rule rule=rulesMap.get(graphNode.getName());
				rulePreRulesNode.setRule(rule);
				////preRules
				List<RuleNode> preRuleNodes=new ArrayList<>();
				////rule对应的triggers
				List<GraphNode> triggerNodes=new ArrayList<>();				
				for(GraphNodeArrow pArrow:graphNode.getpNodeList()) {
					////先找到triggerNode
					triggerNodes.add(pArrow.getGraphNode());
				}
				for(GraphNode triggerNode:triggerNodes) {
					boolean isDeviceState=false;   ////是设备状态才需要前提
					for(GraphNodeArrow pArrow:triggerNode.getpNodeList()) {
						if(pArrow.getGraphNode().getFillcolor().equals("darkseagreen1")) {
							isDeviceState=true;
							break;
						}
					}
					if(isDeviceState) {
						for(GraphNodeArrow pArrow:triggerNode.getpNodeList()) {
							////找前提规则,先找对应action
							if(pArrow.getGraphNode().getShape().equals("record")) {
								GraphNode actionNode=pArrow.getGraphNode();
								for(GraphNodeArrow ppArrow:actionNode.getpNodeList()) {
									////找到action对应的rules
									if(ppArrow.getGraphNode().getShape().equals("hexagon")) {
										RuleNode preRuleNode=new RuleNode();
										Rule preRule=rulesMap.get(ppArrow.getGraphNode().getName());
										preRuleNode.setRule(preRule);
										preRuleNodes.add(preRuleNode);
									}
								}
								break;
							}
						}
					}
				}
				rulePreRulesNode.setPreRules(preRuleNodes);
				rulePreRulesNodes.add(rulePreRulesNode);
			}
		}
		for(RuleNode rulePreRulesNode:rulePreRulesNodes) {
			for(int i=0;i<rulePreRulesNode.getPreRules().size();i++) {
				////替换成rulePreRulesNodes
				RuleNode preRuleNode=rulePreRulesNode.getPreRules().get(i);
				for(RuleNode ruleNode:rulePreRulesNodes) {
					if(preRuleNode.getRule().equals(ruleNode.getRule())) {
						///替换
						rulePreRulesNode.setPreRules(i, ruleNode);
						break;
					}
				}
			}
		}
		
		return rulePreRulesNodes;
	}
	
//	public static List<PropertyVerifyResult> analizeAllproperties(List<String> properties,List<Scene> scenes,List<DeviceDetail> devices,List<BiddableType> biddableTypes,List<GraphNode> graphNodes,HashMap<String,Rule> rulesMap) {
//		List<PropertyVerifyResult> propertyVerifyResults=new ArrayList<>();
//		for(String property:properties) {
//			System.out.println(property);
//			PropertyVerifyResult propertyVerifyResult=propertyAnalysis(property, scenes, devices, biddableTypes, graphNodes, rulesMap);
//			propertyVerifyResults.add(propertyVerifyResult);
//		}
//		return propertyVerifyResults;
//	}
//	
//	///////property验证，看其是否可达，如果可达找原因，对于设备状态，找到触发规则，看在当前能否触发
//	///////"AirConditioner_0.cool & Window_0.wopen"分别找到触发cool和wopen的规则，看都能否触发
//	public static PropertyVerifyResult propertyAnalysis(String property,List<Scene> scenes,List<DeviceDetail> devices,List<BiddableType> biddableTypes,List<GraphNode> graphNodes,HashMap<String,Rule> rulesMap) {
//		PropertyVerifyResult propertyVerifyResult=new PropertyVerifyResult();
//		propertyVerifyResult.setProperty(property);
//		System.out.println(property);
//		
//		////解析出property中的conditions   temperature>30 & Window_0.wclosed
//		List<String> conditions=Arrays.asList(property.split("&"));
//		/////看有哪些场景哪些时间段这些条件能同时满足
//		/////分别找到各个condition满足的时间段，然后取交集
//		List<HashMap<String,List<double[]>>> saperateSatisfySceneTimeHashMapList=new ArrayList<>();
//		List<String[]> deviceActionStateValues=new ArrayList<>();
//		for(String condition:conditions) {
//			condition=condition.trim();
//			String[] attrVal=RuleService.getTriAttrVal(condition, biddableTypes);
//			if(attrVal[1].equals(".")) {
//				String stateValue="";
//				////说明是设备状态
//				device:
//				for(DeviceDetail device:devices) {
//					if(device.getDeviceName().equals(attrVal[0])) {
//						DeviceType deviceType=device.getDeviceType();
//						for(String[] stateActionValue:deviceType.stateActionValues) {
//							if(stateActionValue[0].equals(attrVal[2])) {
//								////找到状态对应的值
//								stateValue=stateActionValue[2];
//								String[] deviceActionStateValue=new String[4];  
//								deviceActionStateValue[0]=device.getDeviceName();   ////设备名
//								deviceActionStateValue[1]=stateActionValue[1];     ////设备状态对应的action
//								deviceActionStateValue[2]=stateActionValue[0];     ////state
//								deviceActionStateValue[3]=stateActionValue[2];     /////value
//								deviceActionStateValues.add(deviceActionStateValue);  ///记录action
//								break device;
//							}
//						}
//					}
//				}
//				////将设备状态改为 device = stateValue
//				attrVal[1]="=";
//				attrVal[2]=stateValue;
//			}
//			/////找到这个condition满足的场景和时间段 scenarioName,String --- timelist,List<double[]>，为double[2], startTime,endTime
//			////HashMap<String,List<double[]>> 满足的场景和时间段   ，key:scenarioName value:timelist
//			HashMap<String,List<double[]>> satisfySceneTimeHashMap=getSatisfySceneTimeListHashMap(attrVal, scenes, devices, biddableTypes);
//			saperateSatisfySceneTimeHashMapList.add(satisfySceneTimeHashMap);
//		}
//		/////看是否存在交集
//		HashMap<String,List<double[]>> allSatisfySceneTimeHashMap=new HashMap<>();
//		for(HashMap<String,List<double[]>> saperateSatisfySceneTimeHashMap:saperateSatisfySceneTimeHashMapList) {
//			if(allSatisfySceneTimeHashMap.isEmpty()) {
//				////如果是空的，表明是第一个,把第一个condition的hashMap存入，作为起始
//				for(Entry<String, List<double[]>> sceneTimeList:saperateSatisfySceneTimeHashMap.entrySet()) {
//					allSatisfySceneTimeHashMap.put(sceneTimeList.getKey(), sceneTimeList.getValue());
//				}
//			}else {
//				for(Entry<String, List<double[]>> sceneTimeList:saperateSatisfySceneTimeHashMap.entrySet()) {
//					////分场景取交集
//					List<double[]> lastSatisfyTimeList=allSatisfySceneTimeHashMap.get(sceneTimeList.getKey());
//					if(lastSatisfyTimeList!=null&&sceneTimeList.getValue()!=null) {
//						////不为空则取交集
//						List<double[]> satisfyTimeList=getIntersaction(lastSatisfyTimeList, sceneTimeList.getValue());
//						if(satisfyTimeList.size()==0) {   //如果没有交集，则为null
//							satisfyTimeList=null;
//						}
//						allSatisfySceneTimeHashMap.put(sceneTimeList.getKey(), satisfyTimeList);
//					}else {
//						allSatisfySceneTimeHashMap.put(sceneTimeList.getKey(), null);
//					}
//				}
//			}
//		}
//		/////看是否有交集,存在交集则说明property可达,但交集的时间不能太短，因为时间太短都还没反应过来呢，不小于5s吧
//		////得到所有能同时满足的时间段，寻找原因
//		////先获得设备状态对应的action。
//		
//		boolean isReachable=false;
//		for(Entry<String, List<double[]>> sceneSatisfyTimeList:allSatisfySceneTimeHashMap.entrySet()) {
//			if(sceneSatisfyTimeList.getValue()!=null) {
//				List<double[]> satisfyTimeList=sceneSatisfyTimeList.getValue();
//				for(double[] satisfyTime:satisfyTimeList) {
//					if((satisfyTime[1]-satisfyTime[0])>5) {
//						isReachable=true;
//						/////可达的话就要找原因
//						System.out.println("Property is reachable.");
//						///获得对应场景
//						Scene scene=new Scene();
//						for(Scene sce:scenes) {
//							if(sce.getScenarioName().equals(sceneSatisfyTimeList.getKey())) {
//								scene=sce;
//							}
//						}
//						////ReachableReason
//						ReachableReason reachableReason=new ReachableReason();
//						reachableReason.setSatisfyIntervalTime(satisfyTime);  ////可达区间，找到该区间可达原因
//						reachableReason.setScenarioName(sceneSatisfyTimeList.getKey());/////可达的场景
//						////IFD上找所有规则的前提规则
//						List<RuleNode> rulePreRules=getRulePreRules(graphNodes, rulesMap);
//						HashMap<String,RuleNode> rulePreRulesMap=new HashMap<>();
//						List<List<RuleNode>> statesCausingRules=new ArrayList<>();
//						for(RuleNode rulePreRule:rulePreRules) {
//							rulePreRulesMap.put(rulePreRule.getRule().getRuleName(), rulePreRule);
//						}
//						////找对应触发的规则
//						for(String[] deviceActionStateValue:deviceActionStateValues) {
//							////分别找到原因
//							////找到IFD上的相关规则
//							////找到对应的设备节点
//							GraphNode deviceNode=new GraphNode();
//							for(GraphNode node:graphNodes) {
//								if(node.getName().equals(deviceActionStateValue[0])) {
//								////找到对应的设备节点
//									deviceNode=node;
//									break;
//								}
//							}
//							////某个状态的causingRules
//							CauseRule causingRule=new CauseRule();
//							causingRule.setState(deviceActionStateValue[0]+"."+deviceActionStateValue[2]);   ////device.state
//							causingRule.setValue(Integer.parseInt(deviceActionStateValue[3]));  ////value
//							List<RuleNode> relatedRulePreRules=getRelatedRulesFromIFD(deviceActionStateValue[1], deviceNode,rulePreRulesMap);
//							////再看能否被触发
//							List<RuleNode> stateCausingRules=getCanTriggeredRules(relatedRulePreRules, scene.getDataStartTimeValueEndTimeValuesHashMap(), satisfyTime[0], satisfyTime[1]);
//							causingRule.setStateCausingRules(stateCausingRules);
//							reachableReason.getCausingRules().add(causingRule);
//							statesCausingRules.add(stateCausingRules);
//							
//
//						}
//						propertyVerifyResult.getReachableReasons().add(reachableReason);
//						System.out.println(statesCausingRules);
//					}
//				}
//			}
//		}
//		if(!isReachable) {
//			System.out.println("Property is not reachabel.");
//		}
//		if(isReachable) {
//			/////如果可达的话，就看是否已经有一条对应规则，当其中一个条件满足时，则会使另一个条件不满足，如果没有则建议添加这条规则
//			boolean existUnsatRule=false;
//			if(deviceActionStateValues.size()==1) {
//				////只有一个是设备相关的
//				for(String condition:conditions) {
//					condition=condition.trim();
//					////找trigger相关
//					String[] attrVal=RuleService.getTriAttrVal(condition, biddableTypes);
//					if(!attrVal[1].equals(".")) {
//						////不是设备相关的
//						for(Entry<String,Rule> ruleKey:rulesMap.entrySet()) {
//							Rule rule=ruleKey.getValue();
//							if(rule.getTrigger().size()==1) {
//								////只有一个trigger
//								////首先有对应的使之不满足的action
//								boolean existUnsatAction=false;
//								for(String action:rule.getAction()) {
//									String deviceName=action.substring(0,action.indexOf(".")).trim();
//									String actionName=action.substring(action.indexOf(".")+1).trim();
//									if(deviceName.equals(deviceActionStateValues.get(0)[0])&&!actionName.equals(deviceActionStateValues.get(0)[1])) {
//										existUnsatAction=true;
//									}
//								}
//								if(!existUnsatAction) {
//									continue;
//								}
//								////再判断trigger是否包含
//								String[] attrVal2=RuleService.getTriAttrVal(rule.getTrigger().get(0), biddableTypes);
//								if(!attrVal2[1].equals(".")) {
//									if(attrVal2[0].equals(attrVal[0])) {
//										///相同属性,看attrVal2是否包含attrVal
//										if(attrVal[1].contains(">")&&attrVal2[1].contains(">")) {
//											if(Double.parseDouble(attrVal2[2])<=Double.parseDouble(attrVal[2])) {
//												existUnsatRule=true;
//												propertyVerifyResult.setHasCorrespondRule(existUnsatRule);
//												propertyVerifyResult.getCorrespondingRules().add(rule);
//												break;
//											}
//										}else if(attrVal[1].contains("<")&&attrVal2[1].contains("<")) {
//											if(Double.parseDouble(attrVal2[2])>=Double.parseDouble(attrVal[2])) {
//												existUnsatRule=true;
//												propertyVerifyResult.setHasCorrespondRule(existUnsatRule);
//												propertyVerifyResult.getCorrespondingRules().add(rule);
//												break;
//											}
//										}else if(attrVal[1].equals("=")&&attrVal2[1].equals("=")) {
//											if(Integer.parseInt(attrVal2[2])==Integer.parseInt(attrVal[2])) {
//												existUnsatRule=true;
//												propertyVerifyResult.setHasCorrespondRule(existUnsatRule);
//												propertyVerifyResult.getCorrespondingRules().add(rule);
//												break;
//											}
//										}
//										
//									}
//								}
//							}
//						}
//						if(!existUnsatRule) {
//							////如果不存在使之不满足的规则
//							propertyVerifyResult.setHasCorrespondRule(existUnsatRule);
//							/////建议添加如下规则
//
//							for(DeviceDetail device:devices) {
//								if(device.getDeviceName().equals(deviceActionStateValues.get(0)[0])){
//									////找到对应设备
//									List<String[]> stateActionValues=device.getDeviceType().getStateActionValues();
//									for(String[] stateActionValue:stateActionValues) {
//										if(!stateActionValue[1].equals(deviceActionStateValues.get(0)[1])) {
//											////找到不一样的action
//											Rule suggestRule=new Rule();
//											////trigger
//											suggestRule.getTrigger().add(condition);
//											/////action根据设备找
//											suggestRule.getAction().add(device.getDeviceName()+"."+stateActionValue[1]);
//											suggestRule.setRuleContent("IF "+condition+" THEN "+device.getDeviceName()+"."+stateActionValue[1]);
//											propertyVerifyResult.getCorrespondingRules().add(suggestRule);
//										}
//									}
//									break;
//								}
//							}
//						}
//						break;
//					}
//					
//				}
//				
//			}else if(deviceActionStateValues.size()==2) {
//				/////如果两个都是设备相关的
//
//				for(Entry<String,Rule> ruleKey:rulesMap.entrySet()) {
//					Rule rule=ruleKey.getValue();
//					if(rule.getTrigger().size()==1) {
//						////只有一个trigger
//						////首先有对应的使之不满足的action
//						boolean existUnsatAction=false;
//						boolean num0Exist=false;  ////表示deviceActionStateValues.get(0)的unsatAction是否存在
//						boolean num1Exist=false;  ////表示deviceActionStateValues.get(1)的unsatAction是否存在
//						for(String action:rule.getAction()) {
//							String deviceName=action.substring(0,action.indexOf(".")).trim();
//							String actionName=action.substring(action.indexOf(".")+1).trim();
//							if(deviceName.equals(deviceActionStateValues.get(0)[0])&&!actionName.equals(deviceActionStateValues.get(0)[1])) {
//								existUnsatAction=true;
//								num0Exist=true;
//							}else if(deviceName.equals(deviceActionStateValues.get(1)[0])&&!actionName.equals(deviceActionStateValues.get(1)[1])) {
//								existUnsatAction=true;
//								num1Exist=true;
//							}
//							
//						}
//						if(!existUnsatAction) {
//							continue;
//						}
//						////再判断trigger是否包含
//						String[] attrVal2=RuleService.getTriAttrVal(rule.getTrigger().get(0), biddableTypes);
//						if(attrVal2[1].equals(".")) {
//							if(num0Exist) {
//								////如果deviceActionStateValues.get(0)的unsatAction存在，看trigger是不是和另一个相同,即get(1)
//								if(attrVal2[0].equals(deviceActionStateValues.get(1)[0])) {
//									///相同设备,看是否同一状态
//									if(attrVal2[2].equals(deviceActionStateValues.get(1)[2])) {
//										existUnsatRule=true;
//										propertyVerifyResult.setHasCorrespondRule(existUnsatRule);
//										propertyVerifyResult.getCorrespondingRules().add(rule);
//										break;
//									}
//									
//								}
//							}
//							if(num1Exist) {
//								////如果deviceActionStateValues.get(1)的unsatAction存在，看trigger是不是和另一个相同,即get(0)
//								if(attrVal2[0].equals(deviceActionStateValues.get(0)[0])) {
//									///相同设备,看是否同一状态
//									if(attrVal2[2].equals(deviceActionStateValues.get(0)[2])) {
//										existUnsatRule=true;
//										propertyVerifyResult.setHasCorrespondRule(existUnsatRule);
//										propertyVerifyResult.getCorrespondingRules().add(rule);
//										break;
//									}
//									
//								}
//							}
//							
//						}
//					}
//				}
//				if(!existUnsatRule) {
//					////如果不存在使之不满足的规则
//					propertyVerifyResult.setHasCorrespondRule(existUnsatRule);
//					/////建议添加如下规则  1.IF device1.state THEN device2.action   2.IF device2.state THEN device1.action 
//
//					for(DeviceDetail device:devices) {
//						if(device.getDeviceName().equals(deviceActionStateValues.get(0)[0])){
//							//////找到对应设备
//							/////// 1.IF device1.state THEN device2.action
//							List<String[]> stateActionValues=device.getDeviceType().getStateActionValues();
//							for(String[] stateActionValue:stateActionValues) {
//								if(!stateActionValue[1].equals(deviceActionStateValues.get(0)[1])) {
//									////找到不一样的action
//									Rule suggestRule=new Rule();
//									////trigger
//									suggestRule.getTrigger().add(deviceActionStateValues.get(1)[0]+"."+deviceActionStateValues.get(1)[2]);
//									/////action根据设备找
//									suggestRule.getAction().add(device.getDeviceName()+"."+stateActionValue[1]);
//									suggestRule.setRuleContent("IF "+deviceActionStateValues.get(1)[0]+"."+deviceActionStateValues.get(1)[2]+" THEN "+device.getDeviceName()+"."+stateActionValue[1]);
//									propertyVerifyResult.getCorrespondingRules().add(suggestRule);
//								}
//							}							
//						}else if(device.getDeviceName().equals(deviceActionStateValues.get(1)[0])){
//							//////找到对应设备
//							///////  2.IF device2.state THEN device1.action 
//							List<String[]> stateActionValues=device.getDeviceType().getStateActionValues();
//							for(String[] stateActionValue:stateActionValues) {
//								if(!stateActionValue[1].equals(deviceActionStateValues.get(1)[1])) {
//									////找到不一样的action
//									Rule suggestRule=new Rule();
//									////trigger
//									suggestRule.getTrigger().add(deviceActionStateValues.get(0)[0]+"."+deviceActionStateValues.get(0)[2]);
//									/////action根据设备找
//									suggestRule.getAction().add(device.getDeviceName()+"."+stateActionValue[1]);
//									suggestRule.setRuleContent("IF "+deviceActionStateValues.get(0)[0]+"."+deviceActionStateValues.get(0)[2]+" THEN "+device.getDeviceName()+"."+stateActionValue[1]);
//									propertyVerifyResult.getCorrespondingRules().add(suggestRule);
//								}
//							}							
//						}
//					}
//				}
//			}
//		}
//		propertyVerifyResult.setReachable(isReachable);
//		return propertyVerifyResult;
//	}
//	
	
	/////找同一场景下满足时间段的交集
	public static List<double[]> getIntersaction(List<double[]> timeList,List<double[]> newTimeList){
		List<double[]> finalTimeList=new ArrayList<double[]>();
		for(int i=0,j=0;i<timeList.size()&&j<newTimeList.size();) {
			if(timeList.get(i)[0]>=newTimeList.get(j)[1]) {
				j++;
				continue;
			}else if(timeList.get(i)[1]<=newTimeList.get(j)[0]) {
				i++;
				continue;
			}
			if(timeList.get(i)[1]<newTimeList.get(j)[1]) {
				double[] time=new double[2];
				time[0]=Math.max(timeList.get(i)[0], newTimeList.get(j)[0]);
				time[1]=timeList.get(i)[1];
				if(time[1]-time[0]>1) {
					finalTimeList.add(time);
				}
				i++;
			}else {
				double[] time=new double[2];
				time[0]=Math.max(timeList.get(i)[0], newTimeList.get(j)[0]);
				time[1]=newTimeList.get(j)[1];
				if(time[1]-time[0]>1) {
					finalTimeList.add(time);
				}
				j++;
			}
					
		}
		return finalTimeList;
	}
	
	/////找到这个condition满足的场景和时间段 scenarioName,String --- timelist,List<double[]>，为double[2], startTime,endTime
	////HashMap<String,List<double[]>> 存储满足的场景和时间段   ，key:scenarioName value:timelist
	public static HashMap<String,List<double[]>> getSatisfySceneTimeListHashMap(String[] attrVal,List<Scene> scenes,List<DeviceDetail> devices,List<BiddableType> biddableTypes) {
		/////解析condition   temperature >= 30,  Person.Out=>position = 0,  Window_0 . wclosed 
//		String[] attrVal=RuleService.getTriAttrVal(condition, biddableTypes);
		HashMap<String,List<double[]>> satisfySceneTimeHashMap=new HashMap<>();
//		if(attrVal[1].equals(".")) {
//			String stateValue="";
//			////说明是设备状态
//			device:
//			for(DeviceDetail device:devices) {
//				if(device.getDeviceName().equals(attrVal[0])) {
//					DeviceType deviceType=device.getDeviceType();
//					for(String[] stateActionValue:deviceType.stateActionValues) {
//						if(stateActionValue[0].equals(attrVal[2])) {
//							////找到状态对应的值
//							stateValue=stateActionValue[2];
//							break device;
//						}
//					}
//				}
//			}
//			////将设备状态改为 device = stateValue
//			attrVal[1]="=";
//			attrVal[2]=stateValue;
//		}
		if(attrVal[1].contains(">")) {
			////// temperature >= 30
			double value=Double.parseDouble(attrVal[2]);    //30
			for(Scene scene:scenes) {
				////获得对应数据名的timeValue。。。
				List<double[]> startTimeValueEndTimeValues=scene.getDataStartTimeValueEndTimeValuesHashMap().get(attrVal[0]);
				////存放满足的时间段
				List<double[]> satisfyStartEndTimeList=new ArrayList<>();
				for(double[] startTimeValueEndTimeValue:startTimeValueEndTimeValues) {
					double startValue=startTimeValueEndTimeValue[1];
					double endValue=startTimeValueEndTimeValue[3];
					double startTime=startTimeValueEndTimeValue[0];
					double endTime=startTimeValueEndTimeValue[2];
					double[] satisfyStartEndTime=new double[2];   //////////存当前这段时间中满足的时间段
					if(startValue<=value&&endValue<=value) {  ///不满足
						continue;
					}
					if(startValue>value) {
						satisfyStartEndTime[0]=startTime;
						if(endValue>=value) {
							satisfyStartEndTime[1]=endTime;
						}else {
							////计算终止时间
							double t=(startTime-endTime)/(startValue-endValue)*(startValue-value);
							satisfyStartEndTime[1]=startTime+t;
						}
					}else if(endValue>value) {
						satisfyStartEndTime[1]=endTime;
						if(startValue>=value) {
							satisfyStartEndTime[0]=startTime;
						}else {
							////计算起始时间
							double t=(startTime-endTime)/(startValue-endValue)*(startValue-value);
							satisfyStartEndTime[0]=startTime+t;
						}
					}
					satisfyStartEndTimeList.add(satisfyStartEndTime);
				}
				if(satisfyStartEndTimeList.size()>0) {
					/////该场景存在满足该condition的时间段,则存入
					satisfySceneTimeHashMap.put(scene.getScenarioName(),satisfyStartEndTimeList);
				}else {
					satisfySceneTimeHashMap.put(scene.getScenarioName(),null);
				}
			}
		}else if(attrVal[1].contains("<")) {
			double value=Double.parseDouble(attrVal[2]);
			for(Scene scene:scenes) {
				////获得对应数据名的timeValue。。。
				List<double[]> startTimeValueEndTimeValues=scene.getDataStartTimeValueEndTimeValuesHashMap().get(attrVal[0]);
				////存放满足的时间段
				List<double[]> satisfyStartEndTimeList=new ArrayList<>();
				for(double[] startTimeValueEndTimeValue:startTimeValueEndTimeValues) {
					double startValue=startTimeValueEndTimeValue[1];
					double endValue=startTimeValueEndTimeValue[3];
					double startTime=startTimeValueEndTimeValue[0];
					double endTime=startTimeValueEndTimeValue[2];
					double[] satisfyStartEndTime=new double[2];   //////////存当前这段时间中满足的时间段
					if(startValue>=value&&endValue>=value) {   ////不满足
						continue;
					}
					if(startValue<value) {
						satisfyStartEndTime[0]=startTime;
						if(endValue<=value) {
							satisfyStartEndTime[1]=endTime;
						}else {
							////计算终止时间
							double t=(startTime-endTime)/(startValue-endValue)*(startValue-value);
							satisfyStartEndTime[1]=startTime+t;
						}
					}else if(endValue<value) {
						satisfyStartEndTime[1]=endTime;
						if(startValue<=value) {
							satisfyStartEndTime[0]=startTime;
						}else {
							////计算起始时间
							double t=(startTime-endTime)/(startValue-endValue)*(startValue-value);
							satisfyStartEndTime[0]=startTime+t;
						}
					}
					satisfyStartEndTimeList.add(satisfyStartEndTime);
				}
				if(satisfyStartEndTimeList.size()>0) {
					/////该场景存在满足该condition的时间段,则存入
					satisfySceneTimeHashMap.put(scene.getScenarioName(),satisfyStartEndTimeList);
				}else {
					satisfySceneTimeHashMap.put(scene.getScenarioName(),null);
				}
			}
		}else if(attrVal[1].contains("=")) {  ////都是对应实体状态
			int value=Integer.parseInt(attrVal[2]);  ///对应状态值
			for(Scene scene:scenes) {
				////获得对应数据名的timeValue。。。
				List<double[]> startTimeValueEndTimeValues=scene.getDataStartTimeValueEndTimeValuesHashMap().get(attrVal[0]);
				////存放满足的时间段
				List<double[]> satisfyStartEndTimeList=new ArrayList<>();
				for(double[] startTimeValueEndTimeValue:startTimeValueEndTimeValues) {
					int startValue=(int) startTimeValueEndTimeValue[1];
					int endValue=(int) startTimeValueEndTimeValue[3];
					double startTime=startTimeValueEndTimeValue[0];
					double endTime=startTimeValueEndTimeValue[2];
					double[] satisfyStartEndTime=new double[2];   //////////存当前这段时间中满足的时间段
					if(startValue==value&&endValue==value) {    /////只有这种情况才满足
						satisfyStartEndTime[0]=startTime;
						satisfyStartEndTime[1]=endTime;
					}else {
						continue;
					}
					satisfyStartEndTimeList.add(satisfyStartEndTime);
				}
				if(satisfyStartEndTimeList.size()>0) {
					/////该场景存在满足该condition的时间段,则存入
					satisfySceneTimeHashMap.put(scene.getScenarioName(),satisfyStartEndTimeList);
				}else {
					satisfySceneTimeHashMap.put(scene.getScenarioName(),null);
				}
			}
		}

		
		return satisfySceneTimeHashMap;
	}
	
	////////抖动分析，看当前场景下，该设备是否会发生抖动
	public static List<JitterReason> jitterAnalysis(List<double[]> startTimeValueEndTimeValues, String simulationTime, String equivalentTime, String intervalTime) {
		
		List<List<double[]>> jitters=new ArrayList<>();    
		
		
		///equivalentTime单位是h，simulationTime单位是clock，intervalTime单位是s
		double multiple=Double.parseDouble(equivalentTime)*3600/Double.parseDouble(simulationTime);
		///deltaTime单位是clock
		double deltaTime=Double.parseDouble(intervalTime)/multiple;
		
		///// [(0,0)(120.0000000000171,0)]，[(120.0000000000171,0) (120.0700000000245,1)]，[(120.0700000000245,1)(149.9999999999993,1)]， 
		////  [(149.9999999999993,1) (150.0700000000085,0)]， [(150.0700000000085,0) (300.0099999998721,0)]

		for(int i=1;i<startTimeValueEndTimeValues.size()-1;i++) {
			/////开头不考虑，最后一个也不考虑
			double[] startTimeValueEndTimeValue=startTimeValueEndTimeValues.get(i);
			double startTime=startTimeValueEndTimeValue[0];
			double endTime=startTimeValueEndTimeValue[2];
			double startValue=startTimeValueEndTimeValue[1];
			double endValue=startTimeValueEndTimeValue[3];
			if((endValue+"").equals(startValue+"")) {
				////如果首位值相等则为持续时间，否则不考虑
				if((endTime-startTime)<deltaTime) {
					/////某个状态持续时间很短，则算一次抖动？如何找原因呢这样，抖动必然是有其他规则使得该状态无法维持下去了
					//////记录startTime v1和nextEndTime v2
					/////如[(120.0700000000245,1)(149.9999999999993,1)]， [(149.9999999999993,1) (150.0700000000085,0)]   
					////  startTime=120.0700000000245 v1=1； nextEndTime=150.0700000000085  v2=0
					
//					double[] jitter=new double[4];
//					jitter[0]=startTime;     ////(120.0700000000245,1) 该状态开始时间
//					jitter[1]=startValue;
//					jitter[2]=startTimeValueEndTimeValues.get(i+1)[2];  ////(150.0700000000085,0)  另一个状态开始时间
//					jitter[3]=startTimeValueEndTimeValues.get(i+1)[3];
					
					
					
					List<double[]> jitterList=new ArrayList<>();
					double[] jitterStart=new double[2];  ////(120.0700000000245,1) 该状态开始时间
					jitterStart[0]=startTime;
					jitterStart[1]=startValue;
					double[] jitterNewStart=new double[2];    ////(150.0700000000085,0)  另一个状态开始时间
					jitterNewStart[0]=startTimeValueEndTimeValues.get(i+1)[2];
					jitterNewStart[1]=startTimeValueEndTimeValues.get(i+1)[3];
					jitterList.add(jitterStart);
					jitterList.add(jitterNewStart);
					jitters.add(jitterList);
				}
			}
		}
		/////实现分段，两个首位相同时间值的可拼接。
		List<JitterReason> jitterReasons=new ArrayList<>();
//		List<List<double[]>> newJitters=new ArrayList<>();
		for(List<double[]> jitter:jitters) {
			if(jitterReasons.isEmpty()) {  ////为空则说明是第一次抖动
				JitterReason jitterReason=new JitterReason();
				jitterReason.setJitter(jitter);
				jitterReasons.add(jitterReason);
			}else {
				////如果当前这次jitter的起始时间和状态和上一个jitter另一个状态的起始时间和状态相同
				String currentStartTime=jitter.get(0)[0]+"";
				String currentStartValue=jitter.get(0)[1]+"";
				List<double[]> lastPartJitter=jitterReasons.get(jitterReasons.size()-1).getJitter();   ////上一段连续抖动
				String lastStartTime=lastPartJitter.get(lastPartJitter.size()-1)[0]+"";  ////上一段连续抖动的最后一个时间值
				String lastStartValue=lastPartJitter.get(lastPartJitter.size()-1)[1]+"";
				if(currentStartTime.equals(lastStartTime)&&currentStartValue.equals(lastStartValue)) {
					/////如果当前jitter的第一个时间值和上一段连续抖动的最后一个时间值相同，则可拼接
					lastPartJitter.add(jitter.get(1));
				}else {
					/////否则作为新一段加入
					JitterReason jitterReason=new JitterReason();
					jitterReason.setJitter(jitter);
					jitterReasons.add(jitterReason);
				}
			}
		}
		
		
		
		return jitterReasons;
	}
	
	//////去掉重复的timeValue？ timeValue => double[2]; ===> startTimeValueEndTimeValue => double[4] ，为了便于抖动分析和property分析？。。
	public static List<double[]> getStartTimeValueEndTimeValuesHashMap(List<double[]> timeValues) {
		List<double[]> startTimeValueEndTimeValues=new ArrayList<>();
		for(int i=0;i<timeValues.size();) {
			/////double[0],[1] startTime,startValue;double[2],[3] endTime,endValue
			/////可能有startValue=endValue，也可能startValue！=endValue
			///// (0,0) (0,0) (120,0) (120.0000000000171,0) (120.0700000000245,1) (120.0700000000245,1) 
			////  (149.9999999999993,1) (150.0700000000085,0) (150.0700000000085,0) (300.0099999998721,0)
			double[] startTimeValueEndTimeValue=new double[4];
			startTimeValueEndTimeValue[0]=timeValues.get(i)[0];   
			startTimeValueEndTimeValue[1]=timeValues.get(i)[1];
			double startTime=timeValues.get(i)[0];   ////起始时间和值
			double startValue=timeValues.get(i)[1];
//			double currentTime=startTime;     ////对应当前指针
//			double currentValue=startValue;
			String t1=startTime+"";           ///(0,0)
			String v1=startValue+""; 
			String currentT=t1;
			String currentV=v1;
			int j=i+1;
			for(;j<timeValues.size();j++) {
				double endTime=timeValues.get(j)[0];
				double endValue=timeValues.get(j)[1];
				String t2=endTime+"";
				String v2=endValue+"";
				if(v2.equals(currentV)) {
					currentV=v2;                //// until (120.0000000000171,0)
					currentT=t2;
//					currentTime=endTime;
//					currentValue=endValue;
					startTimeValueEndTimeValue[2]=endTime;
					startTimeValueEndTimeValue[3]=endValue;
					i=j;
					continue;
				}else {
					if(currentT.equals(t2)) {   ////冲突的点不考虑
						continue;
					}
					if(!currentT.equals(t1)&&currentV.equals(v1)) {  /////如果值相等的区间不小 (0,0)  (120.0000000000171,0)
						break;
					}
					if(!currentV.equals(v2)) {   //////如果两个值不等  (120.0000000000171,0) (120.0700000000245,1)
						startTimeValueEndTimeValue[2]=endTime;
						startTimeValueEndTimeValue[3]=endValue;
						i=j;
						break;
					}
				}
			}
			startTimeValueEndTimeValues.add(startTimeValueEndTimeValue);
			if(j==timeValues.size()) {
				/////如果已经到最后一个timeValue了，则最后一个为end
				startTimeValueEndTimeValue[2]=timeValues.get(j-1)[0];
				startTimeValueEndTimeValue[3]=timeValues.get(j-1)[1];				
				break;
			}
		}
		///// 结果为[(0,0)(120.0000000000171,0)]，[(120.0000000000171,0) (120.0700000000245,1)]，[(120.0700000000245,1)(149.9999999999993,1)]， 
		////  [(149.9999999999993,1) (150.0700000000085,0)]， [(150.0700000000085,0) (300.0099999998721,0)]
		return startTimeValueEndTimeValues;
	}
	
	/////冲突分析，获得当前场景下是否冲突，冲突的时间
	public static List<ConflictReason> conflictAnalysis(List<double[]> timeValues) {
		List<ConflictReason> conflictReasons=new ArrayList<>();
		for(int i=0;i<timeValues.size();) {
			///看是否存在 t1=t2 而 v1!=v2
			Conflict conflict=new Conflict();
			conflict.setTime(timeValues.get(i)[0]);    ////设置冲突时间
			List<Integer> conflictValues=new ArrayList<>();
			double time1=timeValues.get(i)[0];
			double value1=timeValues.get(i)[1];
			String t1=time1+"";
			String v1=value1+"";
			String currentT=t1;
			String currentV=v1;
			int j=i+1;
			for(;j<timeValues.size();j++) {
				String t2=timeValues.get(j)[0]+"";
				String v2=timeValues.get(j)[1]+"";
				if(currentT.equals(t2)&&!currentV.equals(v2)) {
					////表明冲突，add冲突的值，不重复
					////看是否已经有了
					int timeValue=(int) timeValues.get(j)[1];
					boolean exist=false;
					for(Integer value:conflictValues) {
						if(timeValue==value) {
							exist=true;
							break;
						}
					}
					if(!exist) {
						conflictValues.add(timeValue);
					}
					currentT=t2;
					currentV=v2;
				}else {
					i=j;
					break;
				}
			}
			if(j>=timeValues.size()) {
				break;
			}
			
			
			if(conflictValues.size()>0) {
				////有冲突 
				//////add起始值，不重复
				int timeValue=(int) value1;
				boolean exist=false;
				for(Integer value:conflictValues) {
					if(timeValue==value) {
						exist=true;
						break;
					}
				}
				if(!exist) {
					conflictValues.add(timeValue);
				}
				conflict.setConflictValues(conflictValues);
				ConflictReason conflictReason=new ConflictReason();
				conflictReason.setConflict(conflict);
				conflictReasons.add(conflictReason);
			}
		}
//		if(conflictReasons.size()==0) {
//			conflictReasons=null;
//		}
		return conflictReasons;
	}
	
	
	/////生成各个场景的仿真结果
//	public static List<Scene> getAllSimulationResults(ScenesTree scenesTree,List<DeviceDetail> devices,String fileName,String modelFilePath,String uppaalPath,String simulateResultFilePath) {
//		final String fileNameWithoutSuffix=fileName.substring(0, fileName.lastIndexOf(".xml"));
//		final List<Scene> scenes=new ArrayList<>();
//		List<Thread> threads=new ArrayList<>();
//		for(int i=0;i<scenesTree.getChildren().size();i++) {
//			SimulationThreadService sThread=new SimulationThreadService(scenes, devices, uppaalPath, fileNameWithoutSuffix, i+"", modelFilePath,simulateResultFilePath);	
//			sThread.setName("scenario-"+i);
//			threads.add(sThread);
//			sThread.start();			
//		}
//		for(Thread thread:threads) {
//			try {
//				thread.join();
//			} catch (InterruptedException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
//		}
//		Comparator<Scene> c=new Comparator<Scene>() {
//
//			@Override
//			public int compare(Scene s1, Scene s2) {
//				int num1=Integer.parseInt(s1.getScenarioName().substring("scenario-".length()));
//				int num2=Integer.parseInt(s2.getScenarioName().substring("scenario-".length()));
//				if(num1<num2) {
//					return -1;
//				}else {
//					return 1;
//				}
//			}
//		};
//		Collections.sort(scenes, c);
//		return scenes;
//	}
//	
	public static Scene getSingleSimulationResult(List<DeviceDetail> devices,String uppaalPath,String fileNameWithoutSuffix,String scenarioNum,String modelFilePath,String simulationResultFilePath) {
		///仿真
		List<Scene> scenes=new ArrayList<>();
		SimulationThreadService thread=new SimulationThreadService(scenes, devices, uppaalPath, fileNameWithoutSuffix, scenarioNum, modelFilePath, simulationResultFilePath);
		thread.start();
		try {
			thread.join();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return scenes.get(0);
	}
	
	/////将仿真结果解析成 <数据名，（时间，取值）List> 的格式存入hashmap,数据名作为key
	public static HashMap<String,List<double[]>> getDataTimeValuesHashMap(String simulationResult){
		HashMap<String,List<double[]>> dataTimeValuesHashMap=new HashMap<>();
		////按行分割
		List<String> datasValues=Arrays.asList(simulationResult.split("\n"));
		for(int i=0;i<datasValues.size();) {
			String dataValues=datasValues.get(i);
			if(dataValues.indexOf(":")>0 && dataValues.indexOf("[0]")<0) {
				//////数据名			
				String dataName="";  ////存数据名
				List<double[]> timeValues=new ArrayList<>();  ///存该数据的timeValues
				/////获得数据名
				if(dataValues.indexOf("deviceName")>=0) {
					String[] informations=dataValues.split(",");
					for(String information:informations) {
						if(information.contains("deviceName")) {
							///获得设备名，作为分析的标识符，即数据名
							dataName=information.substring(information.indexOf("=")).substring(1).trim();
							break;
						}
					}
				}else {
					dataName=dataValues.substring(0, dataValues.indexOf(":"));
				}				
				i++;
				String valueString=datasValues.get(i);
				if(valueString.indexOf("[0]:")>=0) {
					valueString=valueString.substring("[0]:".length());
//					System.out.println(valueString);
					List<String> timeValueStrs=Arrays.asList(valueString.split(" \\("));					
					for(String timeValueStr:timeValueStrs) {
						/////解析获得timeValue
						if(timeValueStr.indexOf(",")>0) {
							timeValueStr=timeValueStr.substring(0, timeValueStr.indexOf(")"));
							String[] splitTimeValue=timeValueStr.split(",");
							double[] timeValue=new double[2];
							timeValue[0]=Double.parseDouble(splitTimeValue[0]);
//							System.out.println(timeValue[0]);
							timeValue[1]=Double.parseDouble(splitTimeValue[1]);
//							System.out.println(timeValue[1]);
							timeValues.add(timeValue);
						}
					}					
				}
				dataTimeValuesHashMap.put(dataName, timeValues);				
			}
			i++;
		}
		return dataTimeValuesHashMap;
	}
	
	//////获得对应的hashmap
	public static void getSceneDataHashMap(Scene scene){
		for(DataTimeValue dataTimeValue:scene.getDataTimeValues()) {
			scene.getDataTimeValuesHashMap().put(dataTimeValue.getName(), dataTimeValue.getTimeValues());
			scene.getDataStartTimeValueEndTimeValuesHashMap().put(dataTimeValue.getName(), getStartTimeValueEndTimeValuesHashMap(dataTimeValue.getTimeValues()));
		}
		
	}
	/////将仿真结果解析成 （数据名，（时间，取值）） 的格式
	public static List<DataTimeValue> getAllDataTimeValues(String simulationResult){
		List<DataTimeValue> dataTimeValues=new ArrayList<DataTimeValue>();
		////按行分割   ///修改一下文件读取方式
		List<String> datasValues=Arrays.asList(simulationResult.split("\n"));
		for(int i=0;i<datasValues.size();i++) {
			String dataValues=datasValues.get(i).trim();
			if(dataValues.indexOf(":")<0) {
				continue;
			}
			DataTimeValue dataTimeValue=new DataTimeValue();
			String dataName="";
			if(dataValues.indexOf("deviceName")>=0) {
				String[] informations=dataValues.split(",");
				for(String information:informations) {
					if(information.contains("deviceName")) {
						///获得设备名，作为分析的标识符，即数据名
						dataName=information.substring(information.indexOf("=")).substring(1).trim();
						break;
					}
				}
			}else {
				dataName=dataValues.substring(0, dataValues.indexOf(":")).trim();
			}
			dataTimeValue.name=dataName;
			String valueString=dataValues.substring(dataValues.indexOf(":")+1).trim();
			valueString=valueString.substring(1, valueString.length()-1);
			String[] timeValues=valueString.split("\\) \\(");
//			List<String> timeValues=Arrays.asList(valueString.split(") ("));
			for(String timeValueStr:timeValues) {
				if(timeValueStr.indexOf(",")>0) {
//					timeValueStr=timeValueStr.substring(0, timeValueStr.indexOf(")"));
					String[] splitTimeValue=timeValueStr.split(",");
					double[] timeValue=new double[2];
					timeValue[0]=Double.parseDouble(splitTimeValue[0]);
//					System.out.println(timeValue[0]);
					timeValue[1]=Double.parseDouble(splitTimeValue[1]);
//					System.out.println(timeValue[1]);
					dataTimeValue.timeValues.add(timeValue);
				}
			}
			dataTimeValues.add(dataTimeValue);
		}
//		for(int i=0;i<datasValues.size();) {
//			String dataValues=datasValues.get(i);
//			if(dataValues.indexOf(":")>0 && dataValues.indexOf("[0]")<0) {
//				//////数据名
//				DataTimeValue dataTimeValue=new DataTimeValue();
//				String dataName="";
//				if(dataValues.indexOf("deviceName")>=0) {
//					String[] informations=dataValues.split(",");
//					for(String information:informations) {
//						if(information.contains("deviceName")) {
//							///获得设备名，作为分析的标识符，即数据名
//							dataName=information.substring(information.indexOf("=")).substring(1).trim();
//							break;
//						}
//					}
//				}else {
//					dataName=dataValues.substring(0, dataValues.indexOf(":"));
//				}
//				
//				dataTimeValue.name=dataName;
//				i++;
//				String valueString=datasValues.get(i);
//				if(valueString.indexOf("[0]:")>=0) {
//					valueString=valueString.substring("[0]:".length());
////					System.out.println(valueString);
//					List<String> timeValues=Arrays.asList(valueString.split(" \\("));
//					for(String timeValueStr:timeValues) {
//						if(timeValueStr.indexOf(",")>0) {
//							timeValueStr=timeValueStr.substring(0, timeValueStr.indexOf(")"));
//							String[] splitTimeValue=timeValueStr.split(",");
//							double[] timeValue=new double[2];
//							timeValue[0]=Double.parseDouble(splitTimeValue[0]);
////							System.out.println(timeValue[0]);
//							timeValue[1]=Double.parseDouble(splitTimeValue[1]);
////							System.out.println(timeValue[1]);
//							dataTimeValue.timeValues.add(timeValue);
//						}
//					}
//				}
//				dataTimeValues.add(dataTimeValue);
//			}
//			i++;
//		}
		return dataTimeValues;
	}
	
	////CMD 获得仿真结果
	public static String getSimulationResult(String uppaalPath,String fileName,String filePath) {
		  InputStream error = null;
		  	try {

//		  		System.out.println(command.toString());
		  		Process process = Runtime.getRuntime().exec(getLinuxCommand(uppaalPath, fileName, filePath));
		  		error = process.getErrorStream();
//		  		long startTime0=System.currentTimeMillis();
		  		BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream(),Charset.forName("UTF-8")));
//		  		long endTime0=System.currentTimeMillis();
//	  			System.out.println("simulationData time: "+(endTime0-startTime0));
		  		StringBuffer resultBuffer = new StringBuffer();
		  		String s = "";
		  		s = bufferedReader.readLine();
		  		if(s==null) {
		  			System.out.println("null");
		  		}
		  		while (s != null) {
//		  			System.out.println(s);
		  			resultBuffer.append(s+"\n");
//		  			long startTime=System.currentTimeMillis();
		  			s = bufferedReader.readLine();
//		  			long endTime=System.currentTimeMillis();
//		  			System.out.println("readline time: "+(endTime-startTime));
//		  			if(s!=null) {
//		  				System.out.println(s.toString());	
//		  			}
		  			
		  		}
		  		bufferedReader.close();
		  		process.waitFor();
		  		String result=resultBuffer.toString();
		  		int formulaIsSatisfiedIndex=result.indexOf("Formula is satisfied.");
		  		if(formulaIsSatisfiedIndex>=0) {
		  			result=result.substring(formulaIsSatisfiedIndex).substring("Formula is satisfied.".length());
		  		}
		  		return result;
		  	} catch (Exception ex) {
		  		if (error != null) {
		  			try {
		  				error.close();
		  			} catch (IOException e) {
		  				e.printStackTrace();
		  			}
		  		}
		  		return ex.getMessage();
		  	}
	}
	
	public static String getCMDCommand(String uppaalPath,String fileName,String filePath) {
  		StringBuffer command = new StringBuffer();
  		command.append("cmd /c d: ");
  		//这里的&&在多条语句的情况下使用，表示等上一条语句执行成功后在执行下一条命令，
  		//也可以使用&表示执行上一条后台就立刻执行下一条语句
  		command.append(String.format(" && cd %s", uppaalPath));
  		command.append(" && verifyta.exe -O std "+filePath+fileName);
  		return command.toString();
	}
	
	public static String getLinuxCommand(String uppaalPath,String fileName,String filePath) {
  		StringBuffer command = new StringBuffer();
  		//这里的&&在多条语句的情况下使用，表示等上一条语句执行成功后在执行下一条命令，
  		//也可以使用&表示执行上一条后台就立刻执行下一条语句
  		command.append(String.format("%s", uppaalPath));
  		command.append("./verifyta -O std "+filePath+fileName);
  		return command.toString();
	}
}
